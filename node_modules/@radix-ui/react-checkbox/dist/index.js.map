{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/checkbox/src/Checkbox.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { useLabelContext } from '@radix-ui/react-label';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Checkbox\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_NAME = 'Checkbox';\n\ntype ScopedProps<P> = P & { __scopeCheckbox?: Scope };\nconst [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);\n\ntype CheckedState = boolean | 'indeterminate';\n\ntype CheckboxContextValue = {\n  state: CheckedState;\n  disabled?: boolean;\n};\n\nconst [CheckboxProvider, useCheckboxContext] =\n  createCheckboxContext<CheckboxContextValue>(CHECKBOX_NAME);\n\ntype CheckboxElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface CheckboxProps extends Omit<PrimitiveButtonProps, 'checked' | 'defaultChecked'> {\n  checked?: CheckedState;\n  defaultChecked?: CheckedState;\n  required?: boolean;\n  onCheckedChange?(checked: CheckedState): void;\n}\n\nconst Checkbox = React.forwardRef<CheckboxElement, CheckboxProps>(\n  (props: ScopedProps<CheckboxProps>, forwardedRef) => {\n    const {\n      __scopeCheckbox,\n      'aria-labelledby': ariaLabelledby,\n      name,\n      checked: checkedProp,\n      defaultChecked,\n      required,\n      disabled,\n      value = 'on',\n      onCheckedChange,\n      ...checkboxProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const labelId = useLabelContext(button);\n    const labelledBy = ariaLabelledby || labelId;\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? Boolean(button.closest('form')) : true;\n    const [checked = false, setChecked] = useControllableState({\n      prop: checkedProp,\n      defaultProp: defaultChecked,\n      onChange: onCheckedChange,\n    });\n\n    return (\n      <CheckboxProvider scope={__scopeCheckbox} state={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"checkbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          aria-labelledby={labelledBy}\n          aria-required={required}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...checkboxProps}\n          ref={composedRefs}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            // According to WAI ARIA, Checkboxes don't activate on enter keypress\n            if (event.key === 'Enter') event.preventDefault();\n          })}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            setChecked((prevChecked) => (isIndeterminate(prevChecked) ? true : !prevChecked));\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if checkbox is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect checkbox updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n          />\n        )}\n      </CheckboxProvider>\n    );\n  }\n);\n\nCheckbox.displayName = CHECKBOX_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * CheckboxIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'CheckboxIndicator';\n\ntype CheckboxIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface CheckboxIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst CheckboxIndicator = React.forwardRef<CheckboxIndicatorElement, CheckboxIndicatorProps>(\n  (props: ScopedProps<CheckboxIndicatorProps>, forwardedRef) => {\n    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;\n    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);\n    return (\n      <Presence present={forceMount || isIndeterminate(context.state) || context.state === true}>\n        <Primitive.span\n          data-state={getState(context.state)}\n          data-disabled={context.disabled ? '' : undefined}\n          {...indicatorProps}\n          ref={forwardedRef}\n          style={{ pointerEvents: 'none', ...props.style }}\n        />\n      </Presence>\n    );\n  }\n);\n\nCheckboxIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = Radix.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: CheckedState;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      input.indeterminate = isIndeterminate(checked);\n      setChecked.call(input, isIndeterminate(checked) ? false : checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  return (\n    <input\n      type=\"checkbox\"\n      aria-hidden\n      defaultChecked={isIndeterminate(checked) ? false : checked}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nconst Root = Checkbox;\nconst Indicator = CheckboxIndicator;\n\nexport {\n  createCheckboxScope,\n  //\n  Checkbox,\n  CheckboxIndicator,\n  //\n  Root,\n  Indicator,\n};\nexport type { CheckboxProps, CheckboxIndicatorProps };\n"],"names":["dest","source","a","Object","keys","forEach","key","defineProperty","enumerable","get","__esModule","default","createCheckboxContext","createCheckboxScope","createContextScope","CheckboxProvider","useCheckboxContext","Checkbox","React","forwardRef","props","forwardedRef","__scopeCheckbox","ariaLabelledby","name","checked","checkedProp","defaultChecked","required","disabled","value","onCheckedChange","checkboxProps","button","setButton","useState","composedRefs","useComposedRefs","node","labelId","useLabelContext","labelledBy","hasConsumerStoppedPropagationRef","useRef","isFormControl","Boolean","closest","setChecked","useControllableState","prop","defaultProp","onChange","_react","createElement","$eabaedc2140e2004adabe568fc5$var$CheckboxProvider","scope","state","Primitive","_babelRuntimeHelpersExtends","type","role","isIndeterminate","getState","undefined","ref","onKeyDown","composeEventHandlers","event","preventDefault","onClick","prevChecked","current","isPropagationStopped","stopPropagation","$eabaedc2140e2004adabe568fc5$var$BubbleInput","control","bubbles","style","transform","CheckboxIndicator","forceMount","indicatorProps","context","Presence","present","span","pointerEvents","BubbleInput","inputProps","usePrevious","controlSize","useSize","useEffect","input","inputProto","window","HTMLInputElement","prototype","getOwnPropertyDescriptor","set","Event","indeterminate","call","dispatchEvent","tabIndex","position","opacity","margin","Root","Indicator"],"version":3,"file":"index.js.map"}