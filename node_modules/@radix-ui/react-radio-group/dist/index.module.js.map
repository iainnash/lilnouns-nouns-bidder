{"mappings":"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","sources":["./packages/react/radio-group/src/Radio.tsx","./packages/react/radio-group/src/RadioGroup.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useLabelContext } from '@radix-ui/react-label';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Radio\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_NAME = 'Radio';\n\ntype ScopedProps<P> = P & { __scopeRadio?: Scope };\nconst [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);\n\ntype RadioContextValue = { checked: boolean; disabled?: boolean };\nconst [RadioProvider, useRadioContext] = createRadioContext<RadioContextValue>(RADIO_NAME);\n\ntype RadioElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface RadioProps extends PrimitiveButtonProps {\n  checked?: boolean;\n  required?: boolean;\n  onCheck?(): void;\n}\n\nconst Radio = React.forwardRef<RadioElement, RadioProps>(\n  (props: ScopedProps<RadioProps>, forwardedRef) => {\n    const {\n      __scopeRadio,\n      'aria-labelledby': ariaLabelledby,\n      name,\n      checked = false,\n      required,\n      disabled,\n      value = 'on',\n      onCheck,\n      ...radioProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const labelId = useLabelContext(button);\n    const labelledBy = ariaLabelledby || labelId;\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? Boolean(button.closest('form')) : true;\n\n    return (\n      <RadioProvider scope={__scopeRadio} checked={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"radio\"\n          aria-checked={checked}\n          aria-labelledby={labelledBy}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...radioProps}\n          ref={composedRefs}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            // radios cannot be unchecked so we only communicate a checked state\n            if (!checked) onCheck?.();\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if radio is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect radio updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n          />\n        )}\n      </RadioProvider>\n    );\n  }\n);\n\nRadio.displayName = RADIO_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * RadioIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'RadioIndicator';\n\ntype RadioIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\nexport interface RadioIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst RadioIndicator = React.forwardRef<RadioIndicatorElement, RadioIndicatorProps>(\n  (props: ScopedProps<RadioIndicatorProps>, forwardedRef) => {\n    const { __scopeRadio, forceMount, ...indicatorProps } = props;\n    const context = useRadioContext(INDICATOR_NAME, __scopeRadio);\n    return (\n      <Presence present={forceMount || context.checked}>\n        <Primitive.span\n          data-state={getState(context.checked)}\n          data-disabled={context.disabled ? '' : undefined}\n          {...indicatorProps}\n          ref={forwardedRef}\n        />\n      </Presence>\n    );\n  }\n);\n\nRadioIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = Radix.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: boolean;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      setChecked.call(input, checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  return (\n    <input\n      type=\"radio\"\n      aria-hidden\n      defaultChecked={checked}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction getState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nexport {\n  createRadioScope,\n  //\n  Radio,\n  RadioIndicator,\n};\nexport type { RadioProps };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useLabelContext } from '@radix-ui/react-label';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { Radio, RadioIndicator, createRadioScope } from './Radio';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\n/* -------------------------------------------------------------------------------------------------\n * RadioGroup\n * -----------------------------------------------------------------------------------------------*/\nconst RADIO_GROUP_NAME = 'RadioGroup';\n\ntype ScopedProps<P> = P & { __scopeRadioGroup?: Scope };\nconst [createRadioGroupContet, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME, [\n  createRovingFocusGroupScope,\n  createRadioScope,\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\nconst useRadioScope = createRadioScope();\n\ntype RadioGroupContextValue = {\n  name?: string;\n  required: boolean;\n  value?: string;\n  onValueChange(value: string): void;\n};\n\nconst [RadioGroupProvider, useRadioGroupContext] =\n  createRadioGroupContet<RadioGroupContextValue>(RADIO_GROUP_NAME);\n\ntype RadioGroupElement = React.ElementRef<typeof Primitive.div>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RadioGroupProps extends PrimitiveDivProps {\n  name?: RadioGroupContextValue['name'];\n  required?: Radix.ComponentPropsWithoutRef<typeof Radio>['required'];\n  dir?: RovingFocusGroupProps['dir'];\n  orientation?: RovingFocusGroupProps['orientation'];\n  loop?: RovingFocusGroupProps['loop'];\n  defaultValue?: string;\n  value?: RadioGroupContextValue['value'];\n  onValueChange?: RadioGroupContextValue['onValueChange'];\n}\n\nconst RadioGroup = React.forwardRef<RadioGroupElement, RadioGroupProps>(\n  (props: ScopedProps<RadioGroupProps>, forwardedRef) => {\n    const {\n      __scopeRadioGroup,\n      name,\n      'aria-labelledby': ariaLabelledby,\n      defaultValue,\n      value: valueProp,\n      required = false,\n      orientation,\n      dir = 'ltr',\n      loop = true,\n      onValueChange,\n      ...groupProps\n    } = props;\n    const labelId = useLabelContext();\n    const labelledBy = ariaLabelledby || labelId;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeRadioGroup);\n    const [value, setValue] = useControllableState({\n      prop: valueProp,\n      defaultProp: defaultValue,\n      onChange: onValueChange,\n    });\n\n    return (\n      <RadioGroupProvider\n        scope={__scopeRadioGroup}\n        name={name}\n        required={required}\n        value={value}\n        onValueChange={setValue}\n      >\n        <RovingFocusGroup.Root\n          asChild\n          {...rovingFocusGroupScope}\n          orientation={orientation}\n          dir={dir}\n          loop={loop}\n        >\n          <Primitive.div\n            role=\"radiogroup\"\n            aria-orientation={orientation}\n            aria-labelledby={labelledBy}\n            dir={dir}\n            {...groupProps}\n            ref={forwardedRef}\n          />\n        </RovingFocusGroup.Root>\n      </RadioGroupProvider>\n    );\n  }\n);\n\nRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * RadioGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RadioGroupItem';\n\ntype RadioGroupItemElement = React.ElementRef<typeof Radio>;\ntype RadioProps = Radix.ComponentPropsWithoutRef<typeof Radio>;\ninterface RadioGroupItemProps extends Omit<RadioProps, 'onCheck' | 'name'> {\n  value: string;\n}\n\nconst RadioGroupItem = React.forwardRef<RadioGroupItemElement, RadioGroupItemProps>(\n  (props: ScopedProps<RadioGroupItemProps>, forwardedRef) => {\n    const { __scopeRadioGroup, disabled, ...itemProps } = props;\n    const context = useRadioGroupContext(ITEM_NAME, __scopeRadioGroup);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeRadioGroup);\n    const radioScope = useRadioScope(__scopeRadioGroup);\n    const ref = React.useRef<React.ElementRef<typeof Radio>>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const checked = context.value === itemProps.value;\n    const isArrowKeyPressedRef = React.useRef(false);\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (ARROW_KEYS.includes(event.key)) {\n          isArrowKeyPressedRef.current = true;\n        }\n      };\n      const handleKeyUp = () => (isArrowKeyPressedRef.current = false);\n      document.addEventListener('keydown', handleKeyDown);\n      document.addEventListener('keyup', handleKeyUp);\n      return () => {\n        document.removeEventListener('keydown', handleKeyDown);\n        document.removeEventListener('keyup', handleKeyUp);\n      };\n    }, []);\n\n    return (\n      <RovingFocusGroup.Item\n        asChild\n        {...rovingFocusGroupScope}\n        focusable={!disabled}\n        active={checked}\n      >\n        <Radio\n          disabled={disabled}\n          required={context.required}\n          checked={checked}\n          {...radioScope}\n          {...itemProps}\n          name={context.name}\n          ref={composedRefs}\n          onCheck={() => context.onValueChange(itemProps.value)}\n          onKeyDown={composeEventHandlers((event) => {\n            // According to WAI ARIA, radio groups don't activate items on enter keypress\n            if (event.key === 'Enter') event.preventDefault();\n          })}\n          onFocus={composeEventHandlers(itemProps.onFocus, () => {\n            /**\n             * Our `RovingFocusGroup` will focus the radio when navigating with arrow keys\n             * and we need to \"check\" it in that case. We click it to \"check\" it (instead\n             * of updating `context.value`) so that the radio change event fires.\n             */\n            if (isArrowKeyPressedRef.current) ref.current?.click();\n          })}\n        />\n      </RovingFocusGroup.Item>\n    );\n  }\n);\n\nRadioGroupItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * RadioGroupIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'RadioGroupIndicator';\n\ntype RadioGroupIndicatorElement = React.ElementRef<typeof RadioIndicator>;\ntype RadioIndicatorProps = Radix.ComponentPropsWithoutRef<typeof RadioIndicator>;\ninterface RadioGroupIndicatorProps extends RadioIndicatorProps {}\n\nconst RadioGroupIndicator = React.forwardRef<RadioGroupIndicatorElement, RadioGroupIndicatorProps>(\n  (props: ScopedProps<RadioGroupIndicatorProps>, forwardedRef) => {\n    const { __scopeRadioGroup, ...indicatorProps } = props;\n    const radioScope = useRadioScope(__scopeRadioGroup);\n    return <RadioIndicator {...radioScope} {...indicatorProps} ref={forwardedRef} />;\n  }\n);\n\nRadioGroupIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst Root = RadioGroup;\nconst Item = RadioGroupItem;\nconst Indicator = RadioGroupIndicator;\n\nexport {\n  createRadioGroupScope,\n  //\n  RadioGroup,\n  RadioGroupItem,\n  RadioGroupIndicator,\n  //\n  Root,\n  Item,\n  Indicator,\n};\nexport type { RadioGroupProps, RadioGroupItemProps, RadioGroupIndicatorProps };\n"],"names":["createRadioContext","createRadioScope","createContextScope","RadioProvider","useRadioContext","Radio","React","forwardRef","props","forwardedRef","__scopeRadio","ariaLabelledby","name","checked","required","disabled","value","onCheck","radioProps","button","setButton","useState","composedRefs","useComposedRefs","node","labelId","useLabelContext","labelledBy","hasConsumerStoppedPropagationRef","useRef","isFormControl","Boolean","closest","_react","createElement","$f7b37f51b2f1beab198838503d6ba083$var$RadioProvider","scope","Primitive","_babelRuntimeHelpersEsmExtends","type","role","getState","undefined","ref","onClick","composeEventHandlers","event","current","isPropagationStopped","stopPropagation","$f7b37f51b2f1beab198838503d6ba083$var$BubbleInput","control","bubbles","style","transform","RadioIndicator","forceMount","indicatorProps","context","Presence","present","span","BubbleInput","inputProps","prevChecked","usePrevious","controlSize","useSize","useEffect","input","inputProto","window","HTMLInputElement","prototype","setChecked","Object","getOwnPropertyDescriptor","set","Event","call","dispatchEvent","defaultChecked","tabIndex","position","pointerEvents","opacity","margin","ARROW_KEYS","createRadioGroupContet","createRadioGroupScope","createRovingFocusGroupScope","$f7b37f51b2f1beab198838503d6ba083$export$createRadioScope","useRovingFocusGroupScope","useRadioScope","RadioGroupProvider","useRadioGroupContext","RadioGroup","__scopeRadioGroup","defaultValue","valueProp","orientation","dir","loop","onValueChange","groupProps","rovingFocusGroupScope","setValue","useControllableState","prop","defaultProp","onChange","$b7d81d84737f46dda013f23006a0b2fd$var$RadioGroupProvider","_radixUiReactRovingFocus","Root","asChild","div","RadioGroupItem","itemProps","radioScope","isArrowKeyPressedRef","handleKeyDown","includes","key","handleKeyUp","document","addEventListener","removeEventListener","Item","focusable","active","$f7b37f51b2f1beab198838503d6ba083$export$Radio","onKeyDown","preventDefault","onFocus","_ref$current","click","RadioGroupIndicator","$f7b37f51b2f1beab198838503d6ba083$export$RadioIndicator","Indicator"],"version":3,"file":"index.module.js.map"}