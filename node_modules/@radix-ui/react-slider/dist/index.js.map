{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/slider/src/Slider.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","import * as React from 'react';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-use-direction';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createCollection } from '@radix-ui/react-collection';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst PAGE_KEYS = ['PageUp', 'PageDown'];\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\nconst BACK_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowDown', 'Home', 'ArrowLeft', 'PageDown'],\n  rtl: ['ArrowDown', 'Home', 'ArrowRight', 'PageDown'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Slider\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLIDER_NAME = 'Slider';\n\nconst [Collection, useCollection, createCollectionScope] =\n  createCollection<SliderThumbElement>(SLIDER_NAME);\n\ntype ScopedProps<P> = P & { __scopeSlider?: Scope };\nconst [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [\n  createCollectionScope,\n]);\n\ntype SliderContextValue = {\n  disabled?: boolean;\n  min: number;\n  max: number;\n  values: number[];\n  valueIndexToChangeRef: React.MutableRefObject<number>;\n  thumbs: Set<SliderThumbElement>;\n  orientation: SliderProps['orientation'];\n};\n\nconst [SliderProvider, useSliderContext] = createSliderContext<SliderContextValue>(SLIDER_NAME);\n\ntype SliderElement = SliderHorizontalElement | SliderVerticalElement;\ninterface SliderProps\n  extends Omit<\n    SliderHorizontalProps | SliderVerticalProps,\n    keyof SliderOrientationPrivateProps | 'defaultValue'\n  > {\n  name?: string;\n  disabled?: boolean;\n  orientation?: React.AriaAttributes['aria-orientation'];\n  dir?: Direction;\n  min?: number;\n  max?: number;\n  step?: number;\n  minStepsBetweenThumbs?: number;\n  value?: number[];\n  defaultValue?: number[];\n  onValueChange?(value: number[]): void;\n}\n\nconst Slider = React.forwardRef<SliderElement, SliderProps>(\n  (props: ScopedProps<SliderProps>, forwardedRef) => {\n    const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = 'horizontal',\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {},\n      ...sliderProps\n    } = props;\n    const [slider, setSlider] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const thumbRefs = React.useRef<SliderContextValue['thumbs']>(new Set());\n    const valueIndexToChangeRef = React.useRef<number>(0);\n    const isHorizontal = orientation === 'horizontal';\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = slider ? Boolean(slider.closest('form')) : true;\n    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n\n    const [values = [], setValues] = useControllableState({\n      prop: value,\n      defaultProp: defaultValue,\n      onChange: (value) => {\n        const thumbs = [...thumbRefs.current];\n        thumbs[valueIndexToChangeRef.current]?.focus();\n        onValueChange(value);\n      },\n    });\n\n    function handleSlideStart(value: number) {\n      const closestIndex = getClosestValueIndex(values, value);\n      updateValues(value, closestIndex);\n    }\n\n    function handleSlideMove(value: number) {\n      updateValues(value, valueIndexToChangeRef.current);\n    }\n\n    function updateValues(value: number, atIndex: number) {\n      const decimalCount = getDecimalCount(step);\n      const snapToStep = roundValue(Math.round((value - min) / step) * step + min, decimalCount);\n      const nextValue = clamp(snapToStep, [min, max]);\n\n      setValues((prevValues = []) => {\n        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n          return String(nextValues) === String(prevValues) ? prevValues : nextValues;\n        } else {\n          return prevValues;\n        }\n      });\n    }\n\n    return (\n      <SliderProvider\n        scope={props.__scopeSlider}\n        disabled={disabled}\n        min={min}\n        max={max}\n        valueIndexToChangeRef={valueIndexToChangeRef}\n        thumbs={thumbRefs.current}\n        values={values}\n        orientation={orientation}\n      >\n        <Collection.Provider scope={props.__scopeSlider}>\n          <Collection.Slot scope={props.__scopeSlider}>\n            <SliderOrientation\n              aria-disabled={disabled}\n              data-disabled={disabled ? '' : undefined}\n              {...sliderProps}\n              ref={composedRefs}\n              min={min}\n              max={max}\n              onSlideStart={disabled ? undefined : handleSlideStart}\n              onSlideMove={disabled ? undefined : handleSlideMove}\n              onHomeKeyDown={() => !disabled && updateValues(min, 0)}\n              onEndKeyDown={() => !disabled && updateValues(max, values.length - 1)}\n              onStepKeyDown={({ event, direction: stepDirection }) => {\n                if (!disabled) {\n                  const isPageKey = PAGE_KEYS.includes(event.key);\n                  const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\n                  const multiplier = isSkipKey ? 10 : 1;\n                  const atIndex = valueIndexToChangeRef.current;\n                  const value = values[atIndex];\n                  const stepInDirection = step * multiplier * stepDirection;\n                  updateValues(value + stepInDirection, atIndex);\n                }\n              }}\n            />\n          </Collection.Slot>\n        </Collection.Provider>\n        {isFormControl &&\n          values.map((value, index) => (\n            <BubbleInput\n              key={index}\n              name={name ? name + (values.length > 1 ? '[]' : '') : undefined}\n              value={value}\n            />\n          ))}\n      </SliderProvider>\n    );\n  }\n);\n\nSlider.displayName = SLIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderHorizontal\n * -----------------------------------------------------------------------------------------------*/\n\nconst [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext<{\n  startEdge: 'bottom' | 'left' | 'right';\n  endEdge: 'top' | 'right' | 'left';\n  size: keyof NonNullable<ReturnType<typeof useSize>>;\n  direction: number;\n}>(SLIDER_NAME, {\n  startEdge: 'left',\n  endEdge: 'right',\n  size: 'width',\n  direction: 1,\n});\n\ntype SliderOrientationPrivateProps = {\n  min: number;\n  max: number;\n  onSlideStart?(value: number): void;\n  onSlideMove?(value: number): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(step: { event: React.KeyboardEvent; direction: number }): void;\n};\ninterface SliderOrientationProps\n  extends Omit<SliderImplProps, keyof SliderImplPrivateProps>,\n    SliderOrientationPrivateProps {}\n\ntype SliderHorizontalElement = SliderImplElement;\ninterface SliderHorizontalProps extends SliderOrientationProps {\n  dir?: Direction;\n}\n\nconst SliderHorizontal = React.forwardRef<SliderHorizontalElement, SliderHorizontalProps>(\n  (props: ScopedProps<SliderHorizontalProps>, forwardedRef) => {\n    const { min, max, dir, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;\n    const [slider, setSlider] = React.useState<SliderImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const rectRef = React.useRef<ClientRect>();\n    const direction = useDirection(slider, dir);\n    const isDirectionLTR = direction === 'ltr';\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || slider!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.width];\n      const output: [number, number] = isDirectionLTR ? [min, max] : [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.left);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isDirectionLTR ? 'left' : 'right'}\n        endEdge={isDirectionLTR ? 'right' : 'left'}\n        direction={isDirectionLTR ? 1 : -1}\n        size=\"width\"\n      >\n        <SliderImpl\n          data-orientation=\"horizontal\"\n          {...sliderProps}\n          ref={composedRefs}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateX(-50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => (rectRef.current = undefined)}\n          onStepKeyDown={(event) => {\n            const isBackKey = BACK_KEYS[direction].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderVertical\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderVerticalElement = SliderImplElement;\ninterface SliderVerticalProps extends SliderOrientationProps {}\n\nconst SliderVertical = React.forwardRef<SliderVerticalElement, SliderVerticalProps>(\n  (props: ScopedProps<SliderVerticalProps>, forwardedRef) => {\n    const { min, max, onSlideStart, onSlideMove, onStepKeyDown, ...sliderProps } = props;\n    const sliderRef = React.useRef<SliderImplElement>(null);\n    const ref = useComposedRefs(forwardedRef, sliderRef);\n    const rectRef = React.useRef<ClientRect>();\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || sliderRef.current!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.height];\n      const output: [number, number] = [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.top);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge=\"bottom\"\n        endEdge=\"top\"\n        size=\"height\"\n        direction={1}\n      >\n        <SliderImpl\n          data-orientation=\"vertical\"\n          {...sliderProps}\n          ref={ref}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateY(50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => (rectRef.current = undefined)}\n          onStepKeyDown={(event) => {\n            const isBackKey = BACK_KEYS.ltr.includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderImpl\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderImplElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ntype SliderImplPrivateProps = {\n  onSlideStart(event: React.PointerEvent): void;\n  onSlideMove(event: React.PointerEvent): void;\n  onSlideEnd(event: React.PointerEvent): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(event: React.KeyboardEvent): void;\n};\ninterface SliderImplProps extends PrimitiveDivProps, SliderImplPrivateProps {}\n\nconst SliderImpl = React.forwardRef<SliderImplElement, SliderImplProps>(\n  (props: ScopedProps<SliderImplProps>, forwardedRef) => {\n    const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n\n    return (\n      <Primitive.span\n        {...sliderProps}\n        ref={forwardedRef}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Home') {\n            onHomeKeyDown(event);\n            // Prevent scrolling to page start\n            event.preventDefault();\n          } else if (event.key === 'End') {\n            onEndKeyDown(event);\n            // Prevent scrolling to page end\n            event.preventDefault();\n          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n            onStepKeyDown(event);\n            // Prevent scrolling for directional key presses\n            event.preventDefault();\n          }\n        })}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const target = event.target as HTMLElement;\n          target.setPointerCapture(event.pointerId);\n          // Prevent browser focus behaviour because we focus a thumb manually when values change.\n          event.preventDefault();\n          // Touch devices have a delay before focusing so won't focus if touch immediately moves\n          // away from target (sliding). We want thumb to focus regardless.\n          if (context.thumbs.has(target)) {\n            target.focus();\n          } else {\n            onSlideStart(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n            onSlideEnd(event);\n          }\n        })}\n      />\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderTrack\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRACK_NAME = 'SliderTrack';\n\ntype SliderTrackElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SliderTrackProps extends PrimitiveSpanProps {}\n\nconst SliderTrack = React.forwardRef<SliderTrackElement, SliderTrackProps>(\n  (props: ScopedProps<SliderTrackProps>, forwardedRef) => {\n    const { __scopeSlider, ...trackProps } = props;\n    const context = useSliderContext(TRACK_NAME, __scopeSlider);\n    return (\n      <Primitive.span\n        data-disabled={context.disabled ? '' : undefined}\n        data-orientation={context.orientation}\n        {...trackProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSliderTrack.displayName = TRACK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderRange\n * -----------------------------------------------------------------------------------------------*/\n\nconst RANGE_NAME = 'SliderRange';\n\ntype SliderRangeElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderRangeProps extends PrimitiveSpanProps {}\n\nconst SliderRange = React.forwardRef<SliderRangeElement, SliderRangeProps>(\n  (props: ScopedProps<SliderRangeProps>, forwardedRef) => {\n    const { __scopeSlider, ...rangeProps } = props;\n    const context = useSliderContext(RANGE_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n    const ref = React.useRef<HTMLSpanElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const valuesCount = context.values.length;\n    const percentages = context.values.map((value) =>\n      convertValueToPercentage(value, context.min, context.max)\n    );\n    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n    const offsetEnd = 100 - Math.max(...percentages);\n\n    return (\n      <Primitive.span\n        data-orientation={context.orientation}\n        data-disabled={context.disabled ? '' : undefined}\n        {...rangeProps}\n        ref={composedRefs}\n        style={{\n          ...props.style,\n          [orientation.startEdge]: offsetStart + '%',\n          [orientation.endEdge]: offsetEnd + '%',\n        }}\n      />\n    );\n  }\n);\n\nSliderRange.displayName = RANGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SliderThumb';\n\ntype SliderThumbElement = SliderThumbImplElement;\ninterface SliderThumbProps extends Omit<SliderThumbImplProps, 'index'> {}\n\nconst SliderThumb = React.forwardRef<SliderThumbElement, SliderThumbProps>(\n  (props: ScopedProps<SliderThumbProps>, forwardedRef) => {\n    const getItems = useCollection(props.__scopeSlider);\n    const [thumb, setThumb] = React.useState<SliderThumbImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const index = React.useMemo(\n      () => (thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1),\n      [getItems, thumb]\n    );\n    return <SliderThumbImpl {...props} ref={composedRefs} index={index} />;\n  }\n);\n\ntype SliderThumbImplElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderThumbImplProps extends PrimitiveSpanProps {\n  index: number;\n}\n\nconst SliderThumbImpl = React.forwardRef<SliderThumbImplElement, SliderThumbImplProps>(\n  (props: ScopedProps<SliderThumbImplProps>, forwardedRef) => {\n    const { __scopeSlider, index, ...thumbProps } = props;\n    const context = useSliderContext(THUMB_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n    const [thumb, setThumb] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const size = useSize(thumb);\n    // We cast because index could be `-1` which would return undefined\n    const value = context.values[index] as number | undefined;\n    const percent =\n      value === undefined ? 0 : convertValueToPercentage(value, context.min, context.max);\n    const label = getLabel(index, context.values.length);\n    const orientationSize = size?.[orientation.size];\n    const thumbInBoundsOffset = orientationSize\n      ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction)\n      : 0;\n\n    React.useEffect(() => {\n      if (thumb) {\n        context.thumbs.add(thumb);\n        return () => {\n          context.thumbs.delete(thumb);\n        };\n      }\n    }, [thumb, context.thumbs]);\n\n    return (\n      <span\n        style={{\n          transform: 'var(--radix-slider-thumb-transform)',\n          position: 'absolute',\n          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,\n        }}\n      >\n        <Collection.ItemSlot scope={props.__scopeSlider}>\n          <Primitive.span\n            role=\"slider\"\n            aria-label={props['aria-label'] || label}\n            aria-valuemin={context.min}\n            aria-valuenow={value}\n            aria-valuemax={context.max}\n            aria-orientation={context.orientation}\n            data-orientation={context.orientation}\n            data-disabled={context.disabled ? '' : undefined}\n            tabIndex={context.disabled ? undefined : 0}\n            {...thumbProps}\n            ref={composedRefs}\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            style={value === undefined ? { display: 'none' } : props.style}\n            onFocus={composeEventHandlers(props.onFocus, () => {\n              context.valueIndexToChangeRef.current = index;\n            })}\n          />\n        </Collection.ItemSlot>\n      </span>\n    );\n  }\n);\n\nSliderThumb.displayName = THUMB_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst BubbleInput = (props: Radix.ComponentPropsWithoutRef<'input'>) => {\n  const { value, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevValue = usePrevious(value);\n\n  // Bubble value change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value') as PropertyDescriptor;\n    const setValue = descriptor.set;\n    if (prevValue !== value && setValue) {\n      const event = new Event('input', { bubbles: true });\n      setValue.call(input, value);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value]);\n\n  /**\n   * We purposefully do not use `type=\"hidden\"` here otherwise forms that\n   * wrap it will not be able to access its value via the FormData API.\n   *\n   * We purposefully do not add the `value` attribute here to allow the value\n   * to be set programatically and bubble to any parent form `onChange` event.\n   * Adding the `value` will cause React to consider the programatic\n   * dispatch a duplicate and it will get swallowed.\n   */\n  return <input style={{ display: 'none' }} {...inputProps} ref={ref} defaultValue={value} />;\n};\n\nfunction getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\n\nfunction convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  return percentPerStep * (value - min);\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nfunction getLabel(index: number, totalValues: number) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return ['Minimum', 'Maximum'][index];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nfunction getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1) return 0;\n  const distances = values.map((value) => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nfunction getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nfunction getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value);\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nfunction hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length;\n}\n\nfunction roundValue(value: number, decimalCount: number) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\n\nconst Root = Slider;\nconst Track = SliderTrack;\nconst Range = SliderRange;\nconst Thumb = SliderThumb;\n\nexport {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n};\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps };\n"],"names":["dest","source","a","Object","keys","forEach","key","defineProperty","enumerable","get","__esModule","default","PAGE_KEYS","ARROW_KEYS","BACK_KEYS","ltr","rtl","Collection","useCollection","createCollectionScope","createCollection","createSliderContext","createSliderScope","createContextScope","SliderProvider","useSliderContext","Slider","React","forwardRef","props","forwardedRef","name","min","max","step","orientation","disabled","minStepsBetweenThumbs","defaultValue","value","onValueChange","sliderProps","slider","setSlider","useState","composedRefs","useComposedRefs","node","thumbRefs","useRef","Set","valueIndexToChangeRef","isHorizontal","isFormControl","Boolean","closest","SliderOrientation","SliderHorizontal","SliderVertical","values","setValues","useControllableState","prop","defaultProp","onChange","_thumbs$valueIndexToC","current","focus","updateValues","atIndex","decimalCount","String","split","length","getDecimalCount","snapToStep","rounder","Math","pow","round","roundValue","nextValue","clamp","prevValues","nextValues","sort","b","getNextSortedValues","minStepsBetweenValues","stepsBetweenValues","slice","map","index","getStepsBetweenValues","hasMinStepsBetweenValues","indexOf","_react","createElement","$d1200e2606daf1025c715b39c863ef09$var$SliderProvider","scope","__scopeSlider","thumbs","$d1200e2606daf1025c715b39c863ef09$var$Collection","Provider","Slot","_babelRuntimeHelpersExtends","undefined","ref","onSlideStart","distances","abs","closestDistance","getClosestValueIndex","onSlideMove","onHomeKeyDown","onEndKeyDown","onStepKeyDown","event","direction","stepDirection","multiplier","includes","shiftKey","$d1200e2606daf1025c715b39c863ef09$var$BubbleInput","SliderOrientationProvider","useSliderOrientationContext","startEdge","endEdge","size","dir","rectRef","useDirection","isDirectionLTR","getValueFromPointer","pointerPosition","rect","getBoundingClientRect","linearScale","width","left","$d1200e2606daf1025c715b39c863ef09$var$SliderOrientationProvider","$d1200e2606daf1025c715b39c863ef09$var$SliderImpl","style","clientX","onSlideEnd","isBackKey","sliderRef","height","top","clientY","SliderImpl","context","Primitive","span","onKeyDown","composeEventHandlers","preventDefault","concat","onPointerDown","target","setPointerCapture","pointerId","has","onPointerMove","hasPointerCapture","onPointerUp","releasePointerCapture","SliderTrack","trackProps","SliderRange","rangeProps","valuesCount","percentages","convertValueToPercentage","offsetStart","offsetEnd","SliderThumb","getItems","thumb","setThumb","useMemo","findIndex","item","$d1200e2606daf1025c715b39c863ef09$var$SliderThumbImpl","SliderThumbImpl","thumbProps","useSize","percent","label","totalValues","getLabel","orientationSize","thumbInBoundsOffset","halfWidth","offset","getThumbInBoundsOffset","useEffect","add","delete","transform","position","ItemSlot","role","tabIndex","display","onFocus","BubbleInput","inputProps","prevValue","usePrevious","input","inputProto","window","HTMLInputElement","prototype","setValue","getOwnPropertyDescriptor","set","Event","bubbles","call","dispatchEvent","output","ratio","Root","Track","Range","Thumb"],"version":3,"file":"index.js.map"}