{"mappings":"2iBAiBA,MAGOA,EAAqBC,GAAqBC,EAH7B,yCAMpB,MAAOC,EAAgBC,GAAoBJ,EANvB,iBAiBpB,MAAMK,oBAASC,EAAMC,YACnB,CAACC,EAAiCC,KAChC,MAAMC,cACJA,EACA,kBAAmBC,EAFfC,KAGJA,EACAC,QAASC,EAJLC,eAKJA,EALIC,SAMJA,EANIC,SAOJA,EAPIC,MAQJA,EAAQ,KARJC,gBASJA,KACGC,GACDZ,GACGa,EAAQC,GAAahB,EAAMiB,SAAmC,MAC/DC,EAAeC,EAAgBhB,GAAeiB,GAASJ,EAAUI,KACjEC,EAAUC,EAAgBP,GAC1BQ,EAAalB,GAAkBgB,EAC/BG,EAAmCxB,EAAMyB,QAAO,GAEhDC,GAAgBX,GAASY,QAAQZ,EAAOa,QAAQ,UAC/CrB,GAAU,EAAOsB,GAAcC,EAAqB,CACzDC,KAAMvB,EACNwB,YAAavB,EACbwB,SAAUpB,iBAGZ,OACEqB,EAAAC,cAACC,EAAD,CAAgBC,MAAOjC,EAAeG,QAASA,EAASI,SAAUA,gBAChEuB,EAAAC,cAACG,EAAUvB,OAAXwB,EAAA,CACEC,KAAK,SACLC,KAAK,SACL,eAAclC,EACd,kBAAiBgB,EACjB,gBAAeb,EACf,aAAYgC,EAASnC,GACrB,gBAAeI,EAAW,QAAKgC,EAC/BhC,SAAUA,EACVC,MAAOA,GACHE,EAVN,CAWE8B,IAAK1B,EACL2B,QAASC,EAAqB5C,EAAM2C,SAAUE,IAC5ClB,GAAYmB,IAAiBA,IACzBtB,IACFF,EAAiCyB,QAAUF,EAAMG,uBAI5C1B,EAAiCyB,SAASF,EAAMI,yBAI1DzB,gBACCQ,EAAAC,cAACiB,EAAD,CACEC,QAAStC,EACTuC,SAAU9B,EAAiCyB,QAC3C3C,KAAMA,EACNM,MAAOA,EACPL,QAASA,EACTG,SAAUA,EACVC,SAAUA,EAIV4C,MAAO,CAAEC,UAAW,+CAoBhC,MAAMC,yBAAczD,EAAMC,YACxB,CAACC,EAAsCC,KACrC,MAAMC,cAAEA,KAAkBsD,GAAexD,EACnCyD,EAAU7D,EATD,cAS8BM,gBAC7C,OACE8B,EAAAC,cAACG,EAAUsB,KAAXrB,EAAA,CACE,aAAYG,EAASiB,EAAQpD,SAC7B,gBAAeoD,EAAQhD,SAAW,QAAKgC,GACnCe,EAHN,CAIEd,IAAKzC,qBAiBb,MAAM0D,EAAe3D,IACnB,MAAMmD,QAAEA,EAAF9C,QAAWA,EAAX+C,QAAoBA,GAAU,KAASQ,GAAe5D,EACtD0C,EAAM5C,EAAMyB,OAAyB,MACrCuB,EAAce,EAAYxD,GAC1ByD,EAAcC,EAAQZ,GAe5B,OAZArD,EAAMkE,WAAU,KACd,MAAMC,EAAQvB,EAAIK,QACZmB,EAAaC,OAAOC,iBAAiBC,UAErC1C,EADa2C,OAAOC,yBAAyBL,EAAY,WACjCM,IAC9B,GAAI1B,IAAgBzC,GAAWsB,EAAY,CACzC,MAAMkB,EAAQ,IAAI4B,MAAM,QAAS,CAAErB,QAAAA,IACnCzB,EAAW+C,KAAKT,EAAO5D,GACvB4D,EAAMU,cAAc9B,MAErB,CAACC,EAAazC,EAAS+C,iBAGxBpB,EAAAC,cAAA,QAAAI,EAAA,CACEC,KAAK,WACL,eAAA,EACA/B,eAAgBF,GACZuD,EAJN,CAKEgB,UAAW,EACXlC,IAAKA,EACLW,MAAO,IACFrD,EAAMqD,SACNS,EACHe,SAAU,WACVC,cAAe,OACfC,QAAS,EACTC,OAAQ,OAMhB,SAASxC,EAASnC,GAChB,OAAOA,EAAU,UAAY,mBAG/B,MAAM4E,KAAOpF,cACb,MAAMqF,MAAQ3B","sources":["./packages/react/switch/src/Switch.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useLabelContext } from '@radix-ui/react-label';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Switch\n * -----------------------------------------------------------------------------------------------*/\n\nconst SWITCH_NAME = 'Switch';\n\ntype ScopedProps<P> = P & { __scopeSwitch?: Scope };\nconst [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);\n\ntype SwitchContextValue = { checked: boolean; disabled?: boolean };\nconst [SwitchProvider, useSwitchContext] = createSwitchContext<SwitchContextValue>(SWITCH_NAME);\n\ntype SwitchElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface SwitchProps extends PrimitiveButtonProps {\n  checked?: boolean;\n  defaultChecked?: boolean;\n  required?: boolean;\n  onCheckedChange?(checked: boolean): void;\n}\n\nconst Switch = React.forwardRef<SwitchElement, SwitchProps>(\n  (props: ScopedProps<SwitchProps>, forwardedRef) => {\n    const {\n      __scopeSwitch,\n      'aria-labelledby': ariaLabelledby,\n      name,\n      checked: checkedProp,\n      defaultChecked,\n      required,\n      disabled,\n      value = 'on',\n      onCheckedChange,\n      ...switchProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const labelId = useLabelContext(button);\n    const labelledBy = ariaLabelledby || labelId;\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? Boolean(button.closest('form')) : true;\n    const [checked = false, setChecked] = useControllableState({\n      prop: checkedProp,\n      defaultProp: defaultChecked,\n      onChange: onCheckedChange,\n    });\n\n    return (\n      <SwitchProvider scope={__scopeSwitch} checked={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"switch\"\n          aria-checked={checked}\n          aria-labelledby={labelledBy}\n          aria-required={required}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...switchProps}\n          ref={composedRefs}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            setChecked((prevChecked) => !prevChecked);\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if switch is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect switch updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n          />\n        )}\n      </SwitchProvider>\n    );\n  }\n);\n\nSwitch.displayName = SWITCH_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SwitchThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SwitchThumb';\n\ntype SwitchThumbElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SwitchThumbProps extends PrimitiveSpanProps {}\n\nconst SwitchThumb = React.forwardRef<SwitchThumbElement, SwitchThumbProps>(\n  (props: ScopedProps<SwitchThumbProps>, forwardedRef) => {\n    const { __scopeSwitch, ...thumbProps } = props;\n    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);\n    return (\n      <Primitive.span\n        data-state={getState(context.checked)}\n        data-disabled={context.disabled ? '' : undefined}\n        {...thumbProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSwitchThumb.displayName = THUMB_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = Radix.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: boolean;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      setChecked.call(input, checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  return (\n    <input\n      type=\"checkbox\"\n      aria-hidden\n      defaultChecked={checked}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction getState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nconst Root = Switch;\nconst Thumb = SwitchThumb;\n\nexport {\n  createSwitchScope,\n  //\n  Switch,\n  SwitchThumb,\n  //\n  Root,\n  Thumb,\n};\nexport type { SwitchProps, SwitchThumbProps };\n"],"names":["createSwitchContext","createSwitchScope","createContextScope","SwitchProvider","useSwitchContext","Switch","React","forwardRef","props","forwardedRef","__scopeSwitch","ariaLabelledby","name","checked","checkedProp","defaultChecked","required","disabled","value","onCheckedChange","switchProps","button","setButton","useState","composedRefs","useComposedRefs","node","labelId","useLabelContext","labelledBy","hasConsumerStoppedPropagationRef","useRef","isFormControl","Boolean","closest","setChecked","useControllableState","prop","defaultProp","onChange","_react","createElement","$a39756f91f0c788d079b2ac1958ff$var$SwitchProvider","scope","Primitive","_babelRuntimeHelpersEsmExtends","type","role","getState","undefined","ref","onClick","composeEventHandlers","event","prevChecked","current","isPropagationStopped","stopPropagation","$a39756f91f0c788d079b2ac1958ff$var$BubbleInput","control","bubbles","style","transform","SwitchThumb","thumbProps","context","span","BubbleInput","inputProps","usePrevious","controlSize","useSize","useEffect","input","inputProto","window","HTMLInputElement","prototype","Object","getOwnPropertyDescriptor","set","Event","call","dispatchEvent","tabIndex","position","pointerEvents","opacity","margin","Root","Thumb"],"version":3,"file":"index.module.js.map"}