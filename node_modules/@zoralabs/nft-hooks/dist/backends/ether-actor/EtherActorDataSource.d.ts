import DataLoader from 'dataloader';
import { NetworkIDs } from '../../constants/networks';
import { EtherActorDataInterface, EtherActorServerResponse } from './EtherActorDataInterface';
import { NFTIdentifier, NFTObject } from '../../types/NFTInterface';
import { NFTQuery, NFTQueryResult } from '../../types/NFTQuery';
export declare class EtherActorDataSource implements EtherActorDataInterface {
    nftsLoader: DataLoader<string, EtherActorServerResponse | Error>;
    endpoint: string;
    timeout: number;
    constructor(networkId: NetworkIDs, timeout?: number);
    loadNFT: ({ contract, id, }: NFTIdentifier) => Promise<EtherActorServerResponse | Error>;
    loadNFTs: (nfts: NFTIdentifier[]) => Promise<(EtherActorServerResponse | Error)[]>;
    canLoadNFT(): boolean;
    transformNFT(asset: EtherActorServerResponse, object?: NFTObject): NFTObject;
    fetchNFTsEtherActor: (nftAddressesAndTokens: readonly string[]) => Promise<(Error | EtherActorServerResponse)[]>;
    queryNFTs(_: NFTQuery): Promise<NFTQueryResult>;
}
