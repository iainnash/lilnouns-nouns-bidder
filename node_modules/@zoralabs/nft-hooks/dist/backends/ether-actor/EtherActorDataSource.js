"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EtherActorDataSource = void 0;
const tslib_1 = require("tslib");
const dataloader_1 = tslib_1.__importDefault(require("dataloader"));
const networks_1 = require("../../constants/networks");
const FetchWithTimeout_1 = require("../../fetcher/FetchWithTimeout");
const NFTInterface_1 = require("../../types/NFTInterface");
const address_1 = require("@ethersproject/address");
const shared_1 = require("../../constants/shared");
const ENDPOINT_PARTS_BY_NETWORK = {
    [networks_1.Networks.MAINNET]: 'mainnet',
    [networks_1.Networks.POLYGON]: 'polygon',
    [networks_1.Networks.MUMBAI]: 'mumbai',
    [networks_1.Networks.RINKEBY]: 'rinkeby',
};
class EtherActorDataSource {
    constructor(networkId, timeout = 10) {
        this.loadNFT = async ({ contract, id, }) => {
            return await this.nftsLoader.load((0, address_1.getAddress)(`${contract}${shared_1.NFT_ID_SEPERATOR}${id}`));
        };
        this.loadNFTs = async (nfts) => {
            return await this.nftsLoader.loadMany(nfts.map((nft) => `${(0, address_1.getAddress)(nft.contract)}${shared_1.NFT_ID_SEPERATOR}${nft.id}`));
        };
        this.fetchNFTsEtherActor = async (nftAddressesAndTokens) => {
            const [address, tokenId] = nftAddressesAndTokens[0].split(':');
            const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeout).fetch(`${this.endpoint}${address}/${tokenId}.json`);
            if (response.status !== 200) {
                throw new Error('No asset');
            }
            const responseJson = (await response.json());
            return [responseJson];
        };
        this.nftsLoader = new dataloader_1.default(this.fetchNFTsEtherActor, {
            maxBatchSize: 1,
        });
        this.endpoint = `https://${ENDPOINT_PARTS_BY_NETWORK[networkId]}.ether.actor/nft/`;
        this.timeout = timeout;
    }
    canLoadNFT() {
        return true;
    }
    transformNFT(asset, object) {
        var _a;
        if (!object) {
            object = { rawData: {} };
        }
        object.nft = {
            tokenId: asset.tokenId,
            contract: {
                address: asset.contract.address,
                name: asset.contract.name || undefined,
                symbol: asset.contract.symbol || undefined,
            },
            owner: {
                address: asset.owner,
            },
            metadataURI: asset.tokenURL,
            contentURI: asset.contentURL,
            minted: {},
        };
        object.metadata = asset.metadata;
        object.media = {
            image: asset.imageURL
                ? {
                    uri: asset.imageURL,
                    mime: asset.imageURLMimeType,
                }
                : undefined,
            source: NFTInterface_1.MEDIA_SOURCES.DERIVED,
            content: asset.contentURL
                ? {
                    uri: asset.contentURL,
                    mime: asset.contentURLMimeType,
                }
                : undefined,
        };
        if (asset.contentURL) {
            object.content = {
                source: NFTInterface_1.MEDIA_SOURCES.DERIVED,
                original: {
                    uri: asset.contentURL,
                    mime: asset.contentURLMimeType,
                },
            };
        }
        object.media = {
            image: asset.imageURL || ((_a = asset.contentURLMimeType) === null || _a === void 0 ? void 0 : _a.startsWith('image'))
                ? {
                    uri: asset.imageURL || asset.contentURL,
                    mime: asset.imageURLMimeType || asset.contentURLMimeType,
                }
                : undefined,
            source: NFTInterface_1.MEDIA_SOURCES.DERIVED,
        };
        object.rawData['EtherActor'] = asset;
        return object;
    }
    queryNFTs(_) {
        throw new Error('not impld');
    }
}
exports.EtherActorDataSource = EtherActorDataSource;
