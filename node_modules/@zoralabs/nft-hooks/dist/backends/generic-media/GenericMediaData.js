"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericMediaData = void 0;
const FetchWithTimeout_1 = require("../../fetcher/FetchWithTimeout");
const RequestError_1 = require("../../fetcher/RequestError");
const UriUtils_1 = require("../../fetcher/UriUtils");
class GenericMediaData {
    constructor(timeout = 5) {
        /**
         * Fetch method to query metadata from IPFS. Not cached
         *
         * @function fetchIPFSMetadataCached
         * @public
         * @param url Metadata Source
         * @returns IPFS Metadata Fetch
         * @throws RequestError
         */
        this.fetchMetadata = async (uri) => {
            const request = await new FetchWithTimeout_1.FetchWithTimeout(this.timeout, 'application/json').fetch((0, UriUtils_1.convertURIToHTTPS)(uri));
            try {
                return await request.json();
            }
            catch (e) {
                throw new RequestError_1.RequestError('Cannot read JSON metadata from IPFS', e);
            }
        };
        /**
         * Fetch NFT content or retun URI if content shouild not be fetched
         * @param url NFT Content URL
         * @param contentType string mime type to fetch
         * @returns Promise<MediaContentType> Media content information or URL
         */
        this.fetchContent = async (url, contentType) => {
            if (contentType.startsWith('text/')) {
                try {
                    const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeout).fetch((0, UriUtils_1.convertURIToHTTPS)(url));
                    return {
                        text: await response.text(),
                        type: 'text',
                        mimeType: contentType,
                    };
                }
                catch (e) {
                    throw new RequestError_1.RequestError('Issue fetching IPFS data', e);
                }
            }
            return { uri: url, type: 'uri', mimeType: contentType };
        };
        /**
         * Fetch Content MIME type from content URI
         *
         * @param url IPFS Content URI
         * @returns mime type as a string
         * @throws RequestError
         */
        this.fetchContentMimeType = async (url) => {
            const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeout).fetch((0, UriUtils_1.convertURIToHTTPS)(url), {
                method: 'HEAD',
            });
            const header = response.headers.get('content-type');
            if (!header) {
                throw new RequestError_1.RequestError('No content type returned for URI');
            }
            return header;
        };
        this.timeout = timeout;
    }
}
exports.GenericMediaData = GenericMediaData;
