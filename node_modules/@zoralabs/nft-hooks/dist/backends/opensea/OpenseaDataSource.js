"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenseaDataSource = void 0;
const tslib_1 = require("tslib");
const dataloader_1 = tslib_1.__importDefault(require("dataloader"));
const urls_1 = require("../../constants/urls");
const FetchWithTimeout_1 = require("../../fetcher/FetchWithTimeout");
const NFTInterface_1 = require("../../types/NFTInterface");
const shared_1 = require("../../constants/shared");
const address_1 = require("@ethersproject/address");
class OpenseaDataSource {
    constructor(networkId, timeout = 10) {
        this.MAX_OPENSEA_SIZE = 50;
        this.loadNFT = async ({ contract, id }) => {
            return await this.nftsLoader.load(`${(0, address_1.getAddress)(contract)}${shared_1.NFT_ID_SEPERATOR}${id}`);
        };
        this.loadNFTs = async (nfts) => {
            return await this.nftsLoader.loadMany(nfts.map((nft) => `${(0, address_1.getAddress)(nft.contract)}${shared_1.NFT_ID_SEPERATOR}${nft.id}`));
        };
        this.fetchNFTsOpensea = async (nftAddressesAndTokens) => {
            const urlParams = [];
            const nftTuples = nftAddressesAndTokens.map((address) => address.toLowerCase().split(shared_1.NFT_ID_SEPERATOR));
            nftTuples.forEach(([address, tokenId]) => {
                urlParams.push(`token_ids=${tokenId}&asset_contract_addresses=${address}`);
            });
            const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeout).fetch(`${this.endpoint}assets?${urlParams.join('&')}&order_direction=desc&limit=${this.MAX_OPENSEA_SIZE}`, { headers: { 'X-API-KEY': '2f6f419a083c46de9d83ce3dbe7db601' } });
            const responseJson = (await response.json());
            return nftTuples.map(([address, tokenId]) => responseJson.assets.find((asset) => asset.token_id === tokenId &&
                asset.asset_contract.address.toLowerCase() === address) || new Error('No asset'));
        };
        this.nftsLoader = new dataloader_1.default(this.fetchNFTsOpensea, {
            maxBatchSize: this.MAX_OPENSEA_SIZE,
            batchScheduleFn: (cb) => setTimeout(cb, 1300),
        });
        this.endpoint = urls_1.OPENSEA_API_URL_BY_NETWORK[networkId];
        this.timeout = timeout;
    }
    canLoadNFT() {
        return true;
    }
    transformNFT(asset, object) {
        var _a, _b, _c;
        if (!object) {
            object = { rawData: {} };
        }
        object.nft = {
            tokenId: asset.token_id.toString(),
            contract: {
                address: (_a = asset.asset_contract) === null || _a === void 0 ? void 0 : _a.address,
                name: asset.asset_contract.name || undefined,
                symbol: asset.asset_contract.symbol || undefined,
                description: asset.asset_contract.description || undefined,
                imageUri: asset.asset_contract.image_url || undefined,
            },
            owner: {
                address: (_b = asset.owner) === null || _b === void 0 ? void 0 : _b.address,
            },
            metadataURI: asset.token_metadata || undefined,
            contentURI: asset.animation_original_url || asset.image_original_url || undefined,
            minted: {
                address: (_c = asset.creator) === null || _c === void 0 ? void 0 : _c.address,
            },
        };
        object.metadata = {
            name: asset.name || undefined,
            description: asset.description || undefined,
            contentUri: asset.animation_url || undefined,
            imageUri: asset.image_url || undefined,
            attributes: asset.traits.map((trait) => ({
                name: trait.trait_type,
                value: trait.value,
                display: trait.display_type,
            })),
        };
        object.media = {
            thumbnail: asset.image_thumbnail_url
                ? {
                    uri: asset.image_thumbnail_url,
                }
                : undefined,
            image: asset.image_url || asset.animation_url
                ? {
                    uri: asset.animation_url || asset.image_url,
                }
                : undefined,
            source: NFTInterface_1.MEDIA_SOURCES.OPENSEA,
        };
        if (asset.animation_url) {
            object.content = {
                source: NFTInterface_1.MEDIA_SOURCES.OPENSEA,
                original: asset.animation_url
                    ? {
                        uri: asset.animation_url || asset.image_original_url,
                    }
                    : undefined,
            };
        }
        if (!object.rawData) {
            object.rawData = {};
        }
        object.rawData['OpenSea'] = asset;
        return object;
    }
    queryNFTs(_) {
        throw new Error('not implemented');
    }
}
exports.OpenseaDataSource = OpenseaDataSource;
