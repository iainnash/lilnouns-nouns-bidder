"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZDKDataSource = exports.transformMarkets = exports.transformEvents = exports.transformNFTZDK = exports.SortDirection = exports.ViewType = exports.MarketType = void 0;
const tslib_1 = require("tslib");
const index_1 = require("@zoralabs/zdk/dist/index");
const queries_sdk_1 = require("@zoralabs/zdk/dist/queries/queries-sdk");
const NFTQuery_1 = require("../../types/NFTQuery");
const types_1 = require("../../types");
const ErrorUtils_1 = require("../../fetcher/ErrorUtils");
const resolveSortKey_1 = require("./utils/resolveSortKey");
const dateToISO_1 = require("./utils/dateToISO");
const transformEvents_1 = require("./transformUtils/transformEvents");
Object.defineProperty(exports, "transformEvents", { enumerable: true, get: function () { return transformEvents_1.transformEvents; } });
const transformMarkets_1 = require("./transformUtils/transformMarkets");
Object.defineProperty(exports, "transformMarkets", { enumerable: true, get: function () { return transformMarkets_1.transformMarkets; } });
const getChainFromNetwork_1 = require("./utils/getChainFromNetwork");
const dataloader_1 = tslib_1.__importDefault(require("dataloader"));
// this enums are params for useNFTQuery()
var NFTQuery_2 = require("../../types/NFTQuery");
Object.defineProperty(exports, "MarketType", { enumerable: true, get: function () { return NFTQuery_2.MarketType; } });
Object.defineProperty(exports, "ViewType", { enumerable: true, get: function () { return NFTQuery_2.ViewType; } });
Object.defineProperty(exports, "SortDirection", { enumerable: true, get: function () { return NFTQuery_2.SortDirection; } });
function transformNFTZDK(tokenResponse, object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;
    if (!object) {
        object = { rawData: {} };
    }
    const { token } = tokenResponse;
    object.nft = {
        tokenId: token.tokenId,
        tokenUrlMimeType: token.tokenUrlMimeType || undefined,
        contract: {
            address: token.collectionAddress,
            name: ((_a = token.tokenContract) === null || _a === void 0 ? void 0 : _a.name) || undefined,
            symbol: ((_b = token.tokenContract) === null || _b === void 0 ? void 0 : _b.symbol) || undefined,
        },
        minted: {
            address: ((_c = token.mintInfo) === null || _c === void 0 ? void 0 : _c.originatorAddress) || undefined,
            at: token.mintInfo
                ? {
                    timestamp: (0, dateToISO_1.dateToISO)(token.mintInfo.mintContext.blockTimestamp),
                    blockNumber: token.mintInfo.mintContext.blockNumber,
                    transactionHash: token.mintInfo.mintContext.transactionHash || undefined,
                }
                : undefined,
        },
        owner: token.owner
            ? {
                address: token.owner,
            }
            : undefined,
        metadataURI: token.tokenUrl || undefined,
        contentURI: ((_d = token.content) === null || _d === void 0 ? void 0 : _d.url) || undefined,
    };
    // Response of token query
    if (tokenResponse.__typename === 'TokenWithFullMarketHistory') {
        object.markets = (0, transformMarkets_1.transformMarkets)(tokenResponse.markets);
        object.events = (0, transformEvents_1.transformEvents)(tokenResponse.events);
    }
    // Response of tokens (plural) query
    if (tokenResponse.__typename === 'TokenWithMarketsSummary') {
        object.markets = (0, transformMarkets_1.transformMarkets)(tokenResponse.marketsSummary);
    }
    object.metadata = {
        name: token.name || undefined,
        description: token.description || undefined,
        contentUri: ((_e = token.content) === null || _e === void 0 ? void 0 : _e.url) || undefined,
        imageUri: ((_f = token.image) === null || _f === void 0 ? void 0 : _f.url) || undefined,
        attributes: (_g = token.attributes) === null || _g === void 0 ? void 0 : _g.map((item) => ({
            name: item.traitType || undefined,
            value: item.value || undefined,
            display: item.displayType || undefined,
        })),
        raw: token.metadata,
    };
    let thumbnail = undefined;
    if (((_j = (_h = token.image) === null || _h === void 0 ? void 0 : _h.mediaEncoding) === null || _j === void 0 ? void 0 : _j.__typename) === 'ImageEncodingTypes' &&
        token.image.mediaEncoding.thumbnail) {
        thumbnail = {
            uri: token.image.mediaEncoding.thumbnail,
        };
    }
    if (((_l = (_k = token.content) === null || _k === void 0 ? void 0 : _k.mediaEncoding) === null || _l === void 0 ? void 0 : _l.__typename) === 'ImageEncodingTypes' &&
        token.content.mediaEncoding.thumbnail) {
        thumbnail = {
            uri: token.content.mediaEncoding.thumbnail,
        };
    }
    let large = undefined;
    if (((_o = (_m = token.image) === null || _m === void 0 ? void 0 : _m.mediaEncoding) === null || _o === void 0 ? void 0 : _o.__typename) === 'ImageEncodingTypes' &&
        token.image.mediaEncoding.large) {
        large = {
            uri: token.image.mediaEncoding.large,
        };
    }
    if (((_q = (_p = token.content) === null || _p === void 0 ? void 0 : _p.mediaEncoding) === null || _q === void 0 ? void 0 : _q.__typename) === 'ImageEncodingTypes' &&
        token.content.mediaEncoding.large) {
        large = {
            uri: token.content.mediaEncoding.large,
        };
    }
    let poster = undefined;
    if (((_s = (_r = token.image) === null || _r === void 0 ? void 0 : _r.mediaEncoding) === null || _s === void 0 ? void 0 : _s.__typename) === 'ImageEncodingTypes' &&
        token.image.mediaEncoding.poster) {
        poster = {
            uri: token.image.mediaEncoding.poster,
        };
    }
    if (((_u = (_t = token.content) === null || _t === void 0 ? void 0 : _t.mediaEncoding) === null || _u === void 0 ? void 0 : _u.__typename) === 'ImageEncodingTypes' &&
        token.content.mediaEncoding.poster) {
        poster = {
            uri: token.content.mediaEncoding.poster,
        };
    }
    object.media = {
        source: types_1.MEDIA_SOURCES.ZORA,
        mimeType: ((_v = token.image) === null || _v === void 0 ? void 0 : _v.mimeType) || undefined,
        thumbnail,
        large,
        poster,
        image: ((_w = token.image) === null || _w === void 0 ? void 0 : _w.url)
            ? {
                mime: token.image.mimeType || undefined,
                uri: token.image.url,
            }
            : undefined,
    };
    object.content = {
        source: types_1.MEDIA_SOURCES.ZORA,
        mimeType: ((_x = token.content) === null || _x === void 0 ? void 0 : _x.mimeType) || undefined,
        original: (((_z = (_y = token.content) === null || _y === void 0 ? void 0 : _y.mediaEncoding) === null || _z === void 0 ? void 0 : _z.__typename) === 'VideoEncodingTypes' ||
            ((_1 = (_0 = token.content) === null || _0 === void 0 ? void 0 : _0.mediaEncoding) === null || _1 === void 0 ? void 0 : _1.__typename) === 'AudioEncodingTypes') &&
            token.content.mediaEncoding.original
            ? {
                uri: token.content.mediaEncoding.original,
            }
            : undefined,
        large: (((_3 = (_2 = token.content) === null || _2 === void 0 ? void 0 : _2.mediaEncoding) === null || _3 === void 0 ? void 0 : _3.__typename) === 'VideoEncodingTypes' ||
            ((_5 = (_4 = token.content) === null || _4 === void 0 ? void 0 : _4.mediaEncoding) === null || _5 === void 0 ? void 0 : _5.__typename) === 'AudioEncodingTypes') &&
            token.content.mediaEncoding.large
            ? {
                uri: token.content.mediaEncoding.large,
            }
            : undefined,
        poster: ((_7 = (_6 = token.content) === null || _6 === void 0 ? void 0 : _6.mediaEncoding) === null || _7 === void 0 ? void 0 : _7.__typename) === 'VideoEncodingTypes' &&
            token.content.mediaEncoding.poster
            ? {
                uri: token.content.mediaEncoding.poster,
            }
            : undefined,
        thumbnail: ((_9 = (_8 = token.content) === null || _8 === void 0 ? void 0 : _8.mediaEncoding) === null || _9 === void 0 ? void 0 : _9.__typename) === 'VideoEncodingTypes' &&
            token.content.mediaEncoding.thumbnail
            ? {
                uri: token.content.mediaEncoding.thumbnail,
            }
            : undefined,
    };
    if (!object.rawData) {
        object.rawData = {};
    }
    object.rawData['APIIndexer'] = token;
    return object;
}
exports.transformNFTZDK = transformNFTZDK;
class ZDKDataSource {
    constructor(chainId, { apiKey, endpoint }) {
        this.loadNFTs = async (nfts) => {
            return await this.nftDataLoader.loadMany(nfts);
        };
        this.fetchNFTs = async (mediaIds) => {
            const response = await this.zdk.tokens({
                includeFullDetails: true,
                where: {
                    tokens: mediaIds.map((mediaId) => {
                        return {
                            tokenId: mediaId.id,
                            address: mediaId.contract,
                        };
                    }),
                },
            });
            return mediaIds.map((key) => {
                return (response.tokens.nodes.find((token) => token.token.tokenId === key.id &&
                    token.token.collectionAddress.toLowerCase() === key.contract.toLowerCase()) || new ErrorUtils_1.NotFoundError('Missing record'));
            });
        };
        this.loadNFT = async ({ contract, id, }) => {
            const nfts = await this.loadNFTs([
                {
                    contract,
                    id,
                },
            ]);
            return nfts[0];
        };
        this.queryNFTs = async (query) => {
            const marketsQuery = {};
            const marketsFilter = {};
            let marketsSort = undefined;
            marketsQuery.ownerAddresses = query.query.owners;
            marketsQuery.collectionAddresses = query.query.collections;
            if (query.query.activeMarkets) {
                const marketsList = [];
                query.query.activeMarkets.forEach((market) => {
                    if (market === NFTQuery_1.MarketType.AUCTION) {
                        marketsList.push(queries_sdk_1.MarketType.V2Auction);
                    }
                    if (market === NFTQuery_1.MarketType.FIXED_PRICE) {
                        marketsList.push(queries_sdk_1.MarketType.V3Ask);
                        marketsList.push(queries_sdk_1.MarketType.V1Ask);
                        marketsList.push(queries_sdk_1.MarketType.V1BidShare);
                    }
                    if (market === NFTQuery_1.MarketType.ANY_MARKET) {
                        marketsList.push(queries_sdk_1.MarketType.V1Ask);
                        marketsList.push(queries_sdk_1.MarketType.V3Ask);
                        marketsList.push(queries_sdk_1.MarketType.V1BidShare);
                        marketsList.push(queries_sdk_1.MarketType.V2Auction);
                        marketsList.push(queries_sdk_1.MarketType.V1Offer);
                    }
                });
                marketsFilter.marketFilters = marketsList.map((marketType) => ({ marketType }));
            }
            if (query.query.minters) {
                throw new Error('Minters filter not supported');
            }
            if (query.sort) {
                if (query.sort.length > 1) {
                    throw new Error('Can only sort on one column');
                }
                query.sort.forEach((sortItem) => {
                    marketsSort = {
                        sortDirection: sortItem.direction === NFTQuery_1.SortDirection.DESC
                            ? queries_sdk_1.SortDirection.Desc
                            : queries_sdk_1.SortDirection.Asc,
                        sortKey: (0, resolveSortKey_1.resolveSortKey)(sortItem.field),
                    };
                });
            }
            let pagination = {};
            if (query.pagination) {
                if (query.pagination.limit) {
                    pagination.limit = query.pagination.limit;
                }
                if (query.pagination.after) {
                    pagination.after = query.pagination.after;
                }
            }
            const results = await this.zdk.tokens({
                where: marketsQuery,
                filter: marketsFilter,
                sort: marketsSort,
                includeFullDetails: true,
                pagination,
                includeSalesHistory: !!query.additional.includeSaleHistory,
            });
            let paginationResult = {};
            if (results.tokens.nodes) {
                if (results.tokens.nodes.length) {
                    paginationResult.last = results.tokens.pageInfo.endCursor || undefined;
                    paginationResult.limit = results.tokens.pageInfo.limit;
                }
                return {
                    pageInfo: paginationResult,
                    results: results.tokens.nodes.map((nft) => this.transformNFT(nft)),
                };
            }
            return { results: [], pageInfo: paginationResult };
        };
        this.nftDataLoader = new dataloader_1.default(this.fetchNFTs);
        this.zdk = new index_1.ZDK({
            endpoint,
            apiKey,
            networks: [{ network: queries_sdk_1.Network.Ethereum, chain: (0, getChainFromNetwork_1.getChainFromNetwork)(chainId) }],
        });
    }
    canLoadNFT(_) {
        return true;
    }
    transformNFT(token, object) {
        return transformNFTZDK(token, object);
    }
}
exports.ZDKDataSource = ZDKDataSource;
