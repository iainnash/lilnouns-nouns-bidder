import DataLoader from 'dataloader';
import { GraphQLClient } from 'graphql-request';
import { NetworkIDs } from '../../constants/networks';
import { NFTObject } from '../../types/NFTInterface';
import { ReserveAuctionPartialFragment } from './zora-graph-types';
import { GraphAuctionInterface } from './GraphAuctionInterface';
export declare class GraphAuctionDataSource implements GraphAuctionInterface {
    auctionInfoLoader: DataLoader<string, NFTObject>;
    networkId: NetworkIDs;
    timeout: number;
    endpoint: string;
    constructor(networkId: NetworkIDs, endpoint?: string, timeout?: number);
    getClient(): GraphQLClient;
    loadAuctionInfo(contractAddress: string, tokenId: string): Promise<NFTObject>;
    static transformNFT(response: ReserveAuctionPartialFragment): NFTObject;
    fetchAuctionNFTInfo: (tokenAndAddresses: readonly string[]) => Promise<(Error | NFTObject)[]>;
    getAllAuctionsByCurator: (curator: string, active: boolean | undefined, first: number, skip: number) => Promise<NFTObject[]>;
    /**
     * Fetch function to retrieve Graph data for matching curated auctions
     * This function is not cached
     *
     * @function fetchReserveAuctions
     * @private
     * @param curatorIds list of Zora NFT IDs to fetch from the graph datastore
     * @returns mapped transformed list of curated auction results
     */
    fetchReserveAuctions: (curatorIds: readonly string[], isApproved?: boolean | null, first?: number, skip?: number) => Promise<NFTObject[]>;
}
