"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphAuctionDataSource = void 0;
const tslib_1 = require("tslib");
const dataloader_1 = tslib_1.__importDefault(require("dataloader"));
const graphql_request_1 = require("graphql-request");
const __1 = require("../..");
const urls_1 = require("../../constants/urls");
const FetchWithTimeout_1 = require("../../fetcher/FetchWithTimeout");
const NFTInterface_1 = require("../../types/NFTInterface");
const big_js_1 = tslib_1.__importDefault(require("big.js"));
const zora_graph_1 = require("./zora-graph");
const shared_1 = require("../../constants/shared");
const address_1 = require("@ethersproject/address");
function unixTimeNow() {
    return Math.floor(new Date().getTime() / 1000);
}
function priceToPretty(number, decimals) {
    return new big_js_1.default(number).div(new big_js_1.default(10).pow(decimals || 18)).toNumber();
}
function unixToISO(unix) {
    if (!unix) {
        return undefined;
    }
    const unixNumber = typeof unix === 'string' ? parseInt(unix, 10) : unix;
    return new Date(unixNumber * 1000).toISOString();
}
class GraphAuctionDataSource {
    constructor(networkId, endpoint = urls_1.THEGRAPH_API_URL_BY_NETWORK[networkId], timeout = 4) {
        this.fetchAuctionNFTInfo = async (tokenAndAddresses) => {
            const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeout);
            const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {
                fetch: fetchWithTimeout.fetch,
            });
            const response = (await client.request(zora_graph_1.GET_AUCTION_BY_MEDIA, {
                tokens: tokenAndAddresses.map((tokenAndAddress) => tokenAndAddress.toLowerCase()),
            }));
            if (!response.reserveAuctions) {
                throw new __1.RequestError('Missing auction in reponse');
            }
            return tokenAndAddresses
                .map((tokenAndAddress) => response.reserveAuctions.find((auction) => auction.token === tokenAndAddress) ||
                new Error('Missing Record'))
                .map((response) => response instanceof Error
                ? response
                : GraphAuctionDataSource.transformNFT(response));
        };
        this.getAllAuctionsByCurator = async (curator, active, first, skip) => {
            const auctions = (await this.getClient().request(zora_graph_1.GET_AUCTION_BY_CURATOR, {
                curator,
                active: active !== undefined ? [active] : [true, false],
                first,
                skip,
            }));
            return auctions.reserveAuctions.map(GraphAuctionDataSource.transformNFT);
        };
        /**
         * Fetch function to retrieve Graph data for matching curated auctions
         * This function is not cached
         *
         * @function fetchReserveAuctions
         * @private
         * @param curatorIds list of Zora NFT IDs to fetch from the graph datastore
         * @returns mapped transformed list of curated auction results
         */
        this.fetchReserveAuctions = async (curatorIds, isApproved = null, first = 1000, skip = 0) => {
            let query = zora_graph_1.GET_ALL_AUCTIONS;
            if (curatorIds.length) {
                query = zora_graph_1.GET_AUCTION_BY_CURATOR;
            }
            const response = (await this.getClient().request(query, {
                curators: curatorIds.length ? curatorIds : undefined,
                first: first,
                skip: skip,
                approved: isApproved === null ? [true, false] : [isApproved],
            }));
            return response.reserveAuctions.map(GraphAuctionDataSource.transformNFT);
        };
        this.timeout = timeout;
        this.auctionInfoLoader = new dataloader_1.default((keys) => this.fetchAuctionNFTInfo(keys), {
            cache: false,
            maxBatchSize: 300,
        });
        this.networkId = networkId;
        this.endpoint = endpoint;
    }
    getClient() {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeout);
        return new graphql_request_1.GraphQLClient(this.endpoint, {
            fetch: fetchWithTimeout.fetch,
        });
    }
    loadAuctionInfo(contractAddress, tokenId) {
        return this.auctionInfoLoader.load((0, address_1.getAddress)(`${contractAddress.toLowerCase()}${shared_1.NFT_ID_SEPERATOR}${tokenId}`));
    }
    static transformNFT(response) {
        var _a, _b;
        const currentObject = { rawData: {}, markets: [] };
        const getStatus = () => {
            var _a, _b;
            if (!response.approved) {
                return NFTInterface_1.MARKET_INFO_STATUSES.PENDING;
            }
            if (response.finalizedAtTimestamp &&
                (!response.previousBids || ((_a = response.previousBids) === null || _a === void 0 ? void 0 : _a.length) === 0) &&
                !response.currentBid) {
                return NFTInterface_1.MARKET_INFO_STATUSES.CANCELED;
            }
            if (!response.approved ||
                (response.approved &&
                    (!response.previousBids || ((_b = response.previousBids) === null || _b === void 0 ? void 0 : _b.length) === 0) &&
                    !response.currentBid)) {
                return NFTInterface_1.MARKET_INFO_STATUSES.PENDING;
            }
            if (response.finalizedAtTimestamp) {
                return NFTInterface_1.MARKET_INFO_STATUSES.COMPLETE;
            }
            if (response.expectedEndTimestamp &&
                response.expectedEndTimestamp <= unixTimeNow()) {
                return NFTInterface_1.MARKET_INFO_STATUSES.COMPLETE;
            }
            if (response.firstBidTime) {
                return NFTInterface_1.MARKET_INFO_STATUSES.ACTIVE;
            }
            return NFTInterface_1.MARKET_INFO_STATUSES.UNKNOWN;
        };
        function addCurrencyInfo(amount) {
            if (response.auctionCurrency.id === '0x0000000000000000000000000000000000000000') {
                return {
                    currency: response.auctionCurrency.id,
                    name: 'Ethereum',
                    symbol: 'ETH',
                    address: '0x0000000000000000000000000000000000000000',
                    eth: {
                        value: priceToPretty(amount, 18),
                        raw: amount,
                    },
                    amount: {
                        decimals: 18,
                        value: priceToPretty(amount, 18),
                        raw: amount,
                    },
                };
            }
            return {
                address: response.auctionCurrency.id,
                name: response.auctionCurrency.name,
                symbol: response.auctionCurrency.symbol,
                amount: {
                    value: priceToPretty(amount, response.auctionCurrency.decimals || 18),
                    raw: amount,
                    decimals: response.auctionCurrency.decimals || undefined,
                },
            };
        }
        const getAmount = () => {
            var _a;
            // current bid
            if ((_a = response.currentBid) === null || _a === void 0 ? void 0 : _a.amount) {
                return addCurrencyInfo(response.currentBid.amount);
            }
            // final bid
            if (response.previousBids && response.previousBids.length) {
                const finalBid = response.previousBids.find((bid) => bid.bidType === 'Final');
                return formatBid(finalBid).amount;
            }
            return addCurrencyInfo(response.reservePrice);
        };
        const formatBid = (bid) => {
            return {
                creator: bid.bidder.id,
                amount: addCurrencyInfo(bid.amount),
                created: {
                    blockNumber: bid.createdAtBlockNumber,
                    transactionHash: bid.transactionHash,
                    timestamp: unixToISO(bid.createdAtTimestamp),
                },
            };
        };
        const getHighestBid = () => {
            if (response.currentBid) {
                return formatBid(response.currentBid);
            }
            if (response.previousBids && response.previousBids.length) {
                const topBid = [...response.previousBids].sort((a, b) => parseInt(b.amount) - parseInt(a.amount))[0];
                return formatBid(topBid);
            }
            return undefined;
        };
        const auction = {
            status: getStatus(),
            amount: getAmount(),
            auctionId: response.id,
            raw: response,
            type: NFTInterface_1.MARKET_TYPES.AUCTION,
            createdBy: response.curator.id,
            createdAt: {
                timestamp: response.createdAtTimestamp,
                blockNumber: response.createdAtBlockNumber,
                transactionHash: response.transactionHash,
            },
            finishedAt: response.finalizedAtTimestamp
                ? {
                    timestamp: unixToISO(response.finalizedAtTimestamp),
                }
                : undefined,
            startedAt: response.firstBidTime,
            // if cancelled record is deleted
            canceledAt: undefined,
            winner: (_a = response.currentBid) === null || _a === void 0 ? void 0 : _a.bidder.id,
            endsAt: {
                timestamp: unixToISO(response.expectedEndTimestamp),
            },
            duration: response.duration,
            currentBid: getHighestBid(),
            source: NFTInterface_1.AUCTION_SOURCE_TYPES.ZORA_RESERVE_V2,
            bids: [...(((_b = response.previousBids) === null || _b === void 0 ? void 0 : _b.map(formatBid)) || [])],
        };
        currentObject.markets = [auction];
        return currentObject;
    }
}
exports.GraphAuctionDataSource = GraphAuctionDataSource;
