"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZoraGraphDataSource = exports.transformNFTZoraGraph = void 0;
const tslib_1 = require("tslib");
const dataloader_1 = tslib_1.__importDefault(require("dataloader"));
const graphql_request_1 = require("graphql-request");
const addresses_1 = require("../../constants/addresses");
const urls_1 = require("../../constants/urls");
const FetchWithTimeout_1 = require("../../fetcher/FetchWithTimeout");
const zora_graph_1 = require("./zora-graph");
const zora_graph_types_1 = require("./zora-graph-types");
const NFTInterface_1 = require("../../types/NFTInterface");
const GraphAuctionDataSource_1 = require("./GraphAuctionDataSource");
const GenericMediaData_1 = require("../generic-media/GenericMediaData");
const NFTQuery_1 = require("../../types/NFTQuery");
const address_1 = require("@ethersproject/address");
const shared_1 = require("../../constants/shared");
function unixToISO(unix) {
    if (!unix) {
        return undefined;
    }
    const unixNumber = typeof unix === 'string' ? parseInt(unix, 10) : unix;
    return new Date(unixNumber * 1000).toISOString();
}
function transformNFTZoraGraph(mediaContractAddress, { asset, metadata }, object) {
    var _a;
    if (!object) {
        object = { rawData: {} };
    }
    object.markets = (_a = asset.reserveAuctions) === null || _a === void 0 ? void 0 : _a.map((auction) => GraphAuctionDataSource_1.GraphAuctionDataSource.transformNFT(auction).markets).filter((el) => !!el && el.length).map((item) => item[0]);
    object.nft = {
        tokenId: asset.id,
        contract: {
            address: mediaContractAddress,
            name: 'Zora',
            symbol: 'ZORA',
            knownContract: NFTInterface_1.KNOWN_CONTRACTS.ZORA,
        },
        owner: {
            address: asset.owner.id,
        },
        minted: {
            address: asset.creator.id,
            at: {
                timestamp: unixToISO(asset.createdAtTimestamp),
            },
        },
        metadataURI: asset.metadataURI,
        contentURI: asset.contentURI,
    };
    // TODO: load from CDN
    object.media = {
        source: NFTInterface_1.MEDIA_SOURCES.DERIVED,
        content: { uri: asset.contentURI, mime: metadata.mimeType },
    };
    object.content = {
        source: NFTInterface_1.MEDIA_SOURCES.DERIVED,
        original: { uri: asset.contentURI, mime: metadata.mimeType },
    };
    object.metadata = metadata;
    if (!object.rawData) {
        object.rawData = {};
    }
    object.rawData['ZoraGraph'] = asset;
    return object;
}
exports.transformNFTZoraGraph = transformNFTZoraGraph;
class ZoraGraphDataSource {
    constructor(networkId, timeout = 6, endpoint = urls_1.THEGRAPH_API_URL_BY_NETWORK[networkId], genericMetadataFetcher = new GenericMediaData_1.GenericMediaData(6), mediaContractAddress = addresses_1.ZORA_MEDIA_CONTRACT_BY_NETWORK[networkId]) {
        this.loadNFT = async ({ contract, id }) => {
            if (contract.toLowerCase() != this.mediaContractAddress.toLowerCase()) {
                throw new Error('Not zora media contract');
            }
            return await this.nftGraphDataLoader.load(id);
        };
        this.fetchNFTs = async (mediaIds) => {
            const response = (await this.getClient().request(zora_graph_1.GET_MEDIAS_QUERY, {
                query: { id_in: mediaIds },
            }));
            const metadatas = await Promise.all(response.medias
                .map((media) => media.metadataURI)
                .map(this.genericMetadataFetcher.fetchMetadata));
            const mediaData = response.medias.map((_, indx) => ({
                asset: response.medias[indx],
                metadata: metadatas[indx],
            }));
            return mediaIds.map((key) => mediaData.find((response) => response.asset.id === key) ||
                new Error('Missing record'));
        };
        this.queryNFTs = async ({ query, sort, pagination, additional, }) => {
            const userQuery = {};
            if (query.minters) {
                userQuery.creator_in = query.minters;
            }
            if (query.owners) {
                userQuery.owner_in = query.owners;
            }
            if ((sort === null || sort === void 0 ? void 0 : sort.length) && sort.length > 1) {
                throw new Error('Sort for multiple keys not implemented currently');
            }
            let sortKey;
            if ((sort === null || sort === void 0 ? void 0 : sort.length) === 1) {
                const sortItem = sort[0];
                if (sortItem.field === NFTQuery_1.SortField.ACTIVE) {
                    sortKey = zora_graph_types_1.Media_OrderBy.Transfers;
                }
                if (sortItem.field === NFTQuery_1.SortField.MINTED) {
                    sortKey = zora_graph_types_1.Media_OrderBy.CreatedAtBlockNumber;
                }
                if (sortItem.field === NFTQuery_1.SortField.AUCTION_PRICE) {
                    sortKey = zora_graph_types_1.Media_OrderBy.CurrentBids;
                }
                if (sortItem.field === NFTQuery_1.SortField.FIXED_PRICE) {
                    sortKey = zora_graph_types_1.Media_OrderBy.CurrentAsk;
                }
                if (sortItem.field === NFTQuery_1.SortField.TOKEN_ID) {
                    sortKey = zora_graph_types_1.Media_OrderBy.Id;
                }
            }
            let sortDirection;
            if (sortKey && (sort === null || sort === void 0 ? void 0 : sort.length) === 1) {
                sortDirection =
                    sort[0].direction === NFTQuery_1.SortDirection.DESC
                        ? zora_graph_types_1.OrderDirection.Desc
                        : zora_graph_types_1.OrderDirection.Asc;
            }
            let offset = 0;
            let limit = 100;
            if (pagination === null || pagination === void 0 ? void 0 : pagination.after) {
                offset = parseInt(pagination === null || pagination === void 0 ? void 0 : pagination.after, 10);
            }
            if (pagination === null || pagination === void 0 ? void 0 : pagination.limit) {
                limit = pagination === null || pagination === void 0 ? void 0 : pagination.limit;
            }
            const response = (await this.getClient().request(zora_graph_1.GET_MEDIAS_QUERY, {
                query: userQuery,
                orderBy: sortKey,
                orderDirection: sortDirection,
                limit,
                offset,
            }));
            const { medias } = response;
            const metadatas = !(additional === null || additional === void 0 ? void 0 : additional.skipMetadata)
                ? await Promise.all(medias
                    .map((item) => item.metadataURI)
                    .map(this.genericMetadataFetcher.fetchMetadata))
                : medias.map(() => { });
            return {
                results: medias
                    .map((_, indx) => ({
                    asset: response.medias[indx],
                    metadata: metadatas[indx],
                }))
                    .map((nft) => this.transformNFT(nft)),
                pageInfo: { limit: limit, last: (limit + medias.length).toString() }
            };
        };
        this.endpoint = endpoint;
        this.nftGraphDataLoader = new dataloader_1.default(this.fetchNFTs);
        this.timeout = timeout;
        this.networkId = networkId;
        this.mediaContractAddress = mediaContractAddress;
        this.genericMetadataFetcher = genericMetadataFetcher;
    }
    canLoadNFT() {
        return true;
    }
    transformNFT(data, object) {
        return transformNFTZoraGraph(this.mediaContractAddress, data, object);
    }
    async loadNFTs(nfts) {
        return await this.nftGraphDataLoader.loadMany(nfts.map(({ contract, id }) => (0, address_1.getAddress)(`${contract}${shared_1.NFT_ID_SEPERATOR}${id}`)));
    }
    getClient() {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeout);
        return new graphql_request_1.GraphQLClient(this.endpoint, {
            fetch: fetchWithTimeout.fetch,
        });
    }
    /**
     * Un-batched fetch function to fetch a group of ZNFT data
     *
     * @param ids list of ids to query
     * @param type type of ids: creator, id (of media), owner
     * @returns
     */
    async fetchZNFTGroup(ids, type, fetchMetadata = true) {
        const getQuery = () => {
            let base = {
                id_ids: [],
                creator_ids: [],
                owner_ids: [],
            };
            const idsNormalized = ids.map((id) => id.toLowerCase());
            switch (type) {
                case 'id':
                    base.id_ids = idsNormalized;
                    break;
                case 'creator':
                    base.creator_ids = idsNormalized;
                    break;
                case 'owner':
                    base.owner_ids = idsNormalized;
                    break;
            }
            return base;
        };
        const response = (await this.getClient().request(zora_graph_1.GET_MEDIAS_QUERY, getQuery()));
        const { medias } = response;
        const metadatas = fetchMetadata
            ? await Promise.all(medias
                .map((item) => item.metadataURI)
                .map(this.genericMetadataFetcher.fetchMetadata))
            : medias.map(() => { });
        return medias
            .map((_, indx) => ({
            asset: response.medias[indx],
            metadata: metadatas[indx],
        }))
            .map((media) => this.transformNFT(media, { rawData: {} }));
    }
}
exports.ZoraGraphDataSource = ZoraGraphDataSource;
