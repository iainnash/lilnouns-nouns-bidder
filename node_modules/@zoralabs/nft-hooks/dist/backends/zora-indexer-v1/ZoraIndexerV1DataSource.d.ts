import DataLoader from 'dataloader';
import { GraphQLClient } from 'graphql-request';
import { NetworkIDs } from '../../constants/networks';
import { IndexerTokenWithAuctionFragment } from './zora-indexer-types';
import { NFTIdentifier, NFTObject } from '../../types/NFTInterface';
import { ZoraIndexerV1Interface } from './ZoraIndexerV1Interface';
import { NFTQuery } from '../../types/NFTQuery';
export declare function transformNFTZoraIndexerV1DataSource(asset: IndexerTokenWithAuctionFragment, object?: NFTObject): NFTObject;
export declare class ZoraIndexerV1DataSource implements ZoraIndexerV1Interface {
    nftGraphDataLoader: DataLoader<string, IndexerTokenWithAuctionFragment>;
    networkId: NetworkIDs;
    timeout: number;
    endpoint: string;
    mediaContractAddress: string;
    constructor(networkId: NetworkIDs, timeout?: number, mediaContractAddress?: string, endpoint?: string);
    canLoadNFT(): boolean;
    transformNFT(asset: IndexerTokenWithAuctionFragment, object?: NFTObject): NFTObject;
    loadNFT: ({ contract, id }: NFTIdentifier) => Promise<IndexerTokenWithAuctionFragment>;
    loadNFTs: (nfts: readonly NFTIdentifier[]) => Promise<(Error | IndexerTokenWithAuctionFragment)[]>;
    fetchNFTs: (mediaIds: readonly string[]) => Promise<(Error | ({
        __typename?: "Token" | undefined;
    } & {
        __typename?: "Token" | undefined;
    } & {
        auctions: ({
            __typename?: "Auction" | undefined;
        } & {
            __typename?: "Auction" | undefined;
        } & Pick<import("./zora-indexer-types").Auction, "tokenId" | "winner" | "duration" | "reservePrice" | "auctionId" | "firstBidTime" | "approved" | "tokenContract" | "curatorFeePercentage" | "tokenOwner" | "curator" | "lastBidAmount" | "expiresAt" | "curatorFee"> & {
            createdEvent?: import("./zora-indexer-types").Maybe<{
                __typename?: "AuctionCreatedEvent" | undefined;
            } & Pick<import("./zora-indexer-types").AuctionCreatedEvent, "blockNumber" | "transactionHash" | "blockTimestamp">> | undefined;
            currency?: import("./zora-indexer-types").Maybe<{
                __typename?: "Currency" | undefined;
            } & Pick<import("./zora-indexer-types").Currency, "symbol" | "address" | "name" | "decimals">> | undefined;
            canceledEvent?: import("./zora-indexer-types").Maybe<{
                __typename?: "AuctionCanceledEvent" | undefined;
            } & Pick<import("./zora-indexer-types").AuctionCanceledEvent, "blockNumber" | "transactionHash" | "blockTimestamp">> | undefined;
            endedEvent?: import("./zora-indexer-types").Maybe<{
                __typename?: "AuctionEndedEvent" | undefined;
            } & Pick<import("./zora-indexer-types").AuctionEndedEvent, "blockNumber" | "transactionHash" | "blockTimestamp">> | undefined;
            bidEvents: ({
                __typename?: "AuctionBidEvent" | undefined;
            } & {
                __typename?: "AuctionBidEvent" | undefined;
            } & Pick<import("./zora-indexer-types").AuctionBidEvent, "id" | "value" | "sender" | "blockNumber" | "transactionHash" | "blockTimestamp">)[];
        })[];
    } & {
        __typename?: "Token" | undefined;
    } & Pick<import("./zora-indexer-types").Token, "id" | "address" | "tokenId" | "owner" | "tokenURI" | "minter"> & {
        tokenContract?: import("./zora-indexer-types").Maybe<{
            __typename?: "TokenContract" | undefined;
        } & Pick<import("./zora-indexer-types").TokenContract, "symbol" | "address" | "name" | "supportsMetadata">> | undefined;
        metadata?: import("./zora-indexer-types").Maybe<{
            __typename?: "TokenMetadata" | undefined;
        } & Pick<import("./zora-indexer-types").TokenMetadata, "json">> | undefined;
        mintTransferEvent?: import("./zora-indexer-types").Maybe<{
            __typename?: "TokenTransferEvent" | undefined;
        } & Pick<import("./zora-indexer-types").TokenTransferEvent, "blockNumber" | "transactionHash" | "blockTimestamp">> | undefined;
        media?: import("./zora-indexer-types").Maybe<{
            __typename?: "Media" | undefined;
        } & Pick<import("./zora-indexer-types").Media, "metadataURI" | "contentURI" | "creatorBidShare" | "ownerBidShare" | "metadataHash" | "contentHash">> | undefined;
        v3Ask?: import("./zora-indexer-types").Maybe<{
            __typename?: "V3Ask" | undefined;
        } & {
            __typename?: "V3Ask" | undefined;
        } & Pick<import("./zora-indexer-types").V3Ask, "status" | "seller" | "askPrice" | "askCurrency" | "findersFeeBps" | "finder"> & {
            events: ({
                __typename?: "Event" | undefined;
            } & Pick<import("./zora-indexer-types").Event, "address" | "eventType" | "blockNumber" | "transactionHash" | "blockTimestamp">)[];
        }> | undefined;
    } & {
        __typename?: "Token" | undefined;
    } & {
        transferEvents: ({
            __typename?: "TokenTransferEvent" | undefined;
        } & {
            __typename?: "TokenTransferEvent" | undefined;
        } & Pick<import("./zora-indexer-types").TokenTransferEvent, "address" | "from" | "to" | "tokenId" | "blockNumber" | "transactionHash" | "blockTimestamp">)[];
        v3Events: ({
            __typename?: "Event" | undefined;
        } & {
            __typename?: "Event" | undefined;
        } & Pick<import("./zora-indexer-types").Event, "address" | "details" | "eventType" | "blockNumber" | "transactionHash" | "blockTimestamp">)[];
    }))[]>;
    queryNFTs: ({ query, sort, pagination, additional }: NFTQuery) => Promise<{
        pageInfo: {
            limit?: number | undefined;
            last?: string | undefined;
        };
        results: NFTObject[];
    }>;
    /**
     * Un-batched fetch function to fetch a group of NFT data from the zora indexer
     *
     * @param collectionAddresses list of addresses for collection
     * @param userAddress address of user
     * @param type type of ids: creator, id (of media), owner
     * @returns
     */
    fetchZoraIndexerUserOwnedNFTs({ collectionAddresses, userAddress, offset, limit, }: {
        collectionAddresses?: string[];
        userAddress: string;
        offset?: number;
        limit?: number;
    }): Promise<NFTObject[]>;
    /**
     * Un-batched fetch function to fetch a group of NFT data from the zora indexer
     *
     * @param collectionAddresses list of addresses for collection
     * @param userAddress address of user
     * @param type type of ids: creator, id (of media), owner
     * @returns
     */
    fetchUserOwnedNFTs: ({ collectionAddresses, userAddress, offset, limit, }: {
        collectionAddresses?: string[] | undefined;
        userAddress: string;
        offset?: number | undefined;
        limit?: number | undefined;
    }) => Promise<NFTObject[]>;
    getClient(): GraphQLClient;
}
