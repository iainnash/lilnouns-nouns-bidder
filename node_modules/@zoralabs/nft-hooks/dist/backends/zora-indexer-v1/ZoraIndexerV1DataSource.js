"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZoraIndexerV1DataSource = exports.transformNFTZoraIndexerV1DataSource = void 0;
const tslib_1 = require("tslib");
const dataloader_1 = tslib_1.__importDefault(require("dataloader"));
const graphql_request_1 = require("graphql-request");
const address_1 = require("@ethersproject/address");
const big_js_1 = tslib_1.__importDefault(require("big.js"));
const addresses_1 = require("../../constants/addresses");
const urls_1 = require("../../constants/urls");
const FetchWithTimeout_1 = require("../../fetcher/FetchWithTimeout");
const zora_indexer_types_1 = require("./zora-indexer-types");
const NFTInterface_1 = require("../../types/NFTInterface");
const zora_indexer_1 = require("./zora-indexer");
const ErrorUtils_1 = require("../../fetcher/ErrorUtils");
const NFTQuery_1 = require("../../types/NFTQuery");
const shared_1 = require("../../constants/shared");
const dateToISO_1 = require("../zdk/utils/dateToISO");
function unixToISO(unix) {
    if (!unix) {
        return undefined;
    }
    const unixNumber = typeof unix === 'string' ? parseInt(unix, 10) : unix;
    return new Date(unixNumber * 1000).toISOString();
}
function getLast(items) {
    if (items && items.length) {
        return items[items.length - 1];
    }
    return undefined;
}
function priceToPretty(number, decimals) {
    return new big_js_1.default(number).div(new big_js_1.default(10).pow(decimals || 18)).toNumber();
}
function getAttributes(json) {
    const result = [];
    if (json.properties) {
        try {
            Object.keys(json.properties).forEach((name) => {
                result.push({ name, value: json.properties[name] });
            });
        }
        catch (_a) { }
    }
    if (json.attributes) {
        try {
            json.attributes.forEach((attribute) => {
                result.push({
                    name: attribute.trait_type,
                    value: attribute.value,
                    display: attribute.display_type,
                });
            });
        }
        catch (_b) { }
    }
    return result;
}
function timeIsPast(time) {
    return new Date(time).getTime() < new Date().getTime();
}
const getAskEventStatus = (askEvent) => {
    if (askEvent.eventType === 'Ask_v1_AskCreated') {
        return NFTInterface_1.FIXED_PRICE_EVENT_TYPES.FIXED_PRICE_CREATED;
    }
    if (askEvent.eventType === 'Ask_v1_AskFilled') {
        return NFTInterface_1.FIXED_PRICE_EVENT_TYPES.FIXED_PRICE_FILLED;
    }
    if (askEvent.eventType === 'Ask_v1_AskCancelled') {
        return NFTInterface_1.FIXED_PRICE_EVENT_TYPES.FIXED_PRICE_CANCELLED;
    }
    if (askEvent.eventType === 'Ask_v1_AskPriceUpdated') {
        return NFTInterface_1.FIXED_PRICE_EVENT_TYPES.FIXED_PRICE_UPDATED;
    }
    return NFTInterface_1.FIXED_PRICE_EVENT_TYPES.FIXED_PRICE_UPDATED;
};
const getAskStatus = (status) => {
    if (status === 'ACTIVE') {
        return NFTInterface_1.MARKET_INFO_STATUSES.ACTIVE;
    }
    if (status === 'FILLED') {
        return NFTInterface_1.MARKET_INFO_STATUSES.COMPLETE;
    }
    if (status === 'CANCELLED') {
        return NFTInterface_1.MARKET_INFO_STATUSES.CANCELED;
    }
    return NFTInterface_1.MARKET_INFO_STATUSES.UNKNOWN;
};
function extractAsk(ask) {
    const created = ask.events.find((e) => e.eventType === 'Ask_v1_AskCreated');
    return {
        status: getAskStatus(ask.status),
        amount: {
            amount: {
                raw: ask.askPrice,
                value: priceToPretty(ask.askPrice),
                decimals: undefined,
            },
            address: ask.askCurrency,
            name: ask.askCurrency === addresses_1.ZERO_ADDRESS ? 'Ether' : 'UNKN',
            symbol: ask.askCurrency === addresses_1.ZERO_ADDRESS ? 'ETH' : 'UNKN',
            // other info not provided
            // currency.decimals / currency.name / currency.symbol
        },
        side: NFTInterface_1.FIXED_SIDE_TYPES.ASK,
        type: NFTInterface_1.MARKET_TYPES.FIXED_PRICE,
        canceledAt: undefined,
        createdAt: {
            timestamp: (0, dateToISO_1.dateToISO)(created.blockTimestamp),
            blockNumber: created.blockNumber,
            transactionHash: created.transactionHash,
        },
        createdBy: ask.seller,
        finishedAt: undefined,
        // finishedAt: completeEvent
        //   ? {
        //       timestamp: unixToISO(completeEvent.blockTimestamp)!,
        //       blockNumber: completeEvent.blockNumber,
        //       transactionHash: completeEvent.transactionHash,
        //     }
        //   : undefined,
        source: NFTInterface_1.FIXED_PRICE_MARKET_SOURCES.ZORA_ASK_V3,
        raw: ask,
    };
}
function extractAskEvents(askEvents) {
    return askEvents.map((askEvent) => {
        const status = getAskEventStatus(askEvent);
        return {
            at: {
                blockNumber: askEvent.blockNumber,
                timestamp: (0, dateToISO_1.dateToISO)(askEvent.blockTimestamp),
                transactionHash: askEvent.transactionHash,
            },
            blockInfo: {
                blockNumber: askEvent.blockNumber,
                timestamp: (0, dateToISO_1.dateToISO)(askEvent.blockTimestamp),
                transactionHash: askEvent.transactionHash,
            },
            sender: askEvent.details.sender,
            marketAddress: askEvent.address,
            event: status,
            eventType: NFTInterface_1.TOKEN_TRANSFER_EVENT_CONTEXT_TYPES.TOKEN_MARKET_EVENT,
            side: NFTInterface_1.FIXED_SIDE_TYPES.ASK,
            raw: {
                source: NFTInterface_1.FIXED_PRICE_MARKET_SOURCES.ZORA_ASK_V3,
                data: askEvent,
            },
        };
    });
}
function extractAuction(auction) {
    var _a, _b;
    const getStatus = () => {
        if (auction.canceledEvent) {
            return NFTInterface_1.MARKET_INFO_STATUSES.CANCELED;
        }
        if (!auction.approved || (auction.approved && !auction.firstBidTime)) {
            return NFTInterface_1.MARKET_INFO_STATUSES.PENDING;
        }
        if (auction.endedEvent) {
            return NFTInterface_1.MARKET_INFO_STATUSES.COMPLETE;
        }
        if (auction.expiresAt && timeIsPast(auction.expiresAt)) {
            return NFTInterface_1.MARKET_INFO_STATUSES.COMPLETE;
        }
        if (auction.firstBidTime) {
            return NFTInterface_1.MARKET_INFO_STATUSES.ACTIVE;
        }
        return NFTInterface_1.MARKET_INFO_STATUSES.UNKNOWN;
    };
    const addCurrencyInfo = (amount) => {
        const currency = auction.currency;
        return {
            address: currency.address,
            name: currency.name,
            symbol: currency.symbol,
            decimals: currency.decimals,
            amount: {
                raw: amount,
                value: priceToPretty(amount, currency.decimals || 18),
            },
        };
    };
    const getAmount = () => {
        if (auction.lastBidAmount) {
            return addCurrencyInfo(auction.lastBidAmount);
        }
        return addCurrencyInfo(auction.reservePrice);
    };
    const formatBid = (bid) => ({
        creator: bid.sender,
        amount: addCurrencyInfo(bid.value),
        created: {
            timestamp: unixToISO(bid.blockTimestamp),
            blockNumber: bid.blockNumber,
            transactionHash: bid.transactionHash,
        },
    });
    const highestBid = getLast(auction.bidEvents);
    const resultAuction = {
        status: getStatus(),
        amount: getAmount(),
        raw: auction,
        auctionId: auction.auctionId,
        createdAt: {
            timestamp: (0, dateToISO_1.dateToISO)(auction.createdEvent.blockTimestamp),
            blockNumber: auction.createdEvent.blockNumber,
            transactionHash: auction.createdEvent.transactionHash,
        },
        createdBy: auction.tokenOwner || undefined,
        type: NFTInterface_1.MARKET_TYPES.AUCTION,
        finishedAt: auction.endedEvent
            ? {
                timestamp: (0, dateToISO_1.dateToISO)(auction.endedEvent.blockTimestamp),
                blockNumber: auction.endedEvent.blockNumber,
                transactionHash: auction.endedEvent.transactionHash,
            }
            : undefined,
        startedAt: auction.firstBidTime
            ? {
                timestamp: unixToISO(auction.firstBidTime),
            }
            : undefined,
        canceledAt: auction.canceledEvent
            ? {
                timestamp: (0, dateToISO_1.dateToISO)(auction.canceledEvent.blockTimestamp),
                blockNumber: auction.canceledEvent.blockNumber,
                transactionHash: auction.canceledEvent.transactionHash,
            }
            : undefined,
        endsAt: {
            timestamp: (0, dateToISO_1.dateToISO)(auction.expiresAt),
            blockNumber: (_a = auction.endedEvent) === null || _a === void 0 ? void 0 : _a.blockNumber,
            transactionHash: (_b = auction.endedEvent) === null || _b === void 0 ? void 0 : _b.transactionHash,
        },
        winner: highestBid === null || highestBid === void 0 ? void 0 : highestBid.sender,
        duration: auction.duration ? parseInt(auction.duration) : 0,
        currentBid: highestBid ? formatBid(highestBid) : undefined,
        source: NFTInterface_1.AUCTION_SOURCE_TYPES.ZORA_RESERVE_V2,
        bids: [...auction.bidEvents.map((bid) => formatBid(bid))],
    };
    return resultAuction;
}
function getTransferType(transferEvent) {
    if (transferEvent.from === addresses_1.ZERO_ADDRESS) {
        return NFTInterface_1.TOKEN_TRANSFER_EVENT_TYPES.MINT;
    }
    if (transferEvent.to === addresses_1.ZERO_ADDRESS) {
        return NFTInterface_1.TOKEN_TRANSFER_EVENT_TYPES.BURN;
    }
    return NFTInterface_1.TOKEN_TRANSFER_EVENT_TYPES.TRANSFER;
}
function extractTransferEvents(transferEvents) {
    return transferEvents.map((transferEvent) => ({
        from: transferEvent.from,
        to: transferEvent.to,
        collectionAddress: transferEvent.address,
        tokenId: transferEvent.tokenId,
        eventType: NFTInterface_1.TOKEN_TRANSFER_EVENT_CONTEXT_TYPES.TOKEN_TRANSFER_EVENT,
        at: {
            timestamp: (0, dateToISO_1.dateToISO)(transferEvent.blockTimestamp),
            blockNumber: transferEvent.blockNumber,
            transactionHash: transferEvent.transactionHash,
        },
        raw: {
            source: NFTInterface_1.MEDIA_SOURCES.ZORA,
            data: transferEvent,
        },
        type: getTransferType(transferEvent),
    }));
}
function extractMarketData(response, _) {
    return [
        ...response.auctions.map((auction) => extractAuction(auction)),
        ...(response.v3Ask ? [extractAsk(response.v3Ask)] : []),
    ];
}
function transformNFTZoraIndexerV1DataSource(asset, object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!object) {
        object = { rawData: {} };
    }
    object.nft = {
        tokenId: asset.tokenId,
        contract: {
            address: (_a = asset.tokenContract) === null || _a === void 0 ? void 0 : _a.address,
            name: ((_b = asset.tokenContract) === null || _b === void 0 ? void 0 : _b.name) || undefined,
            symbol: ((_c = asset.tokenContract) === null || _c === void 0 ? void 0 : _c.symbol) || undefined,
        },
        minted: {
            at: asset.mintTransferEvent
                ? {
                    blockNumber: asset.mintTransferEvent.blockNumber,
                    // TODO(iain): fix normalization to handle missing date information
                    timestamp: (0, dateToISO_1.dateToISO)(asset.mintTransferEvent.blockTimestamp),
                    transactionHash: asset.mintTransferEvent.transactionHash,
                }
                : undefined,
            address: asset.minter || undefined,
        },
        owner: {
            address: asset.owner,
        },
        metadataURI: asset.media ? asset.media.metadataURI : asset.tokenURI,
        contentURI: (_d = asset.media) === null || _d === void 0 ? void 0 : _d.contentURI,
    };
    const metadata_json = ((_e = asset.metadata) === null || _e === void 0 ? void 0 : _e.json) || {};
    object.metadata = {
        name: metadata_json.name,
        description: metadata_json.description,
        contentUri: metadata_json.animation_url,
        imageUri: metadata_json.image,
        attributes: getAttributes(metadata_json),
        raw: (_f = asset.metadata) === null || _f === void 0 ? void 0 : _f.json,
    };
    object.media = {
        content: ((_g = asset.media) === null || _g === void 0 ? void 0 : _g.contentURI)
            ? {
                uri: (_h = asset.media) === null || _h === void 0 ? void 0 : _h.contentURI,
            }
            : undefined,
        source: NFTInterface_1.MEDIA_SOURCES.ZORA,
    };
    if (!object.rawData) {
        object.rawData = {};
    }
    object.markets = extractMarketData(asset, object);
    object.events = [];
    // extract auction events?
    if ('v3Events' in asset) {
        const assetFull = asset;
        object.events = [
            ...extractAskEvents(assetFull.v3Events),
            ...extractTransferEvents(assetFull.transferEvents),
        ];
    }
    if (!object.rawData) {
        object.rawData = {};
    }
    object.rawData['ZoraIndexer'] = asset;
    return object;
}
exports.transformNFTZoraIndexerV1DataSource = transformNFTZoraIndexerV1DataSource;
class ZoraIndexerV1DataSource {
    constructor(networkId, timeout = 5, mediaContractAddress = addresses_1.ZORA_MEDIA_CONTRACT_BY_NETWORK[networkId], endpoint = urls_1.ZORA_INDEXER_URL_BY_NETWORK[networkId]) {
        this.loadNFT = async ({ contract, id }) => {
            return await this.nftGraphDataLoader.load(`${(0, address_1.getAddress)(contract)}${shared_1.NFT_ID_SEPERATOR}${id}`);
        };
        this.loadNFTs = async (nfts) => {
            return await this.nftGraphDataLoader.loadMany(nfts.map((nft) => `${(0, address_1.getAddress)(nft.contract)}${shared_1.NFT_ID_SEPERATOR}${nft.id}`));
        };
        this.fetchNFTs = async (mediaIds) => {
            const response = (await this.getClient().request(zora_indexer_1.BY_IDS, {
                ids: mediaIds,
            }));
            return mediaIds.map((key) => response.Token.find((media) => media.id === key) || new Error('Missing record'));
        };
        this.queryNFTs = async ({ query, sort, pagination, additional }) => {
            // sanity check
            if (!query.collections && !query.minters && !query.owners) {
                throw new ErrorUtils_1.ArgumentsError('One of Collection / Minter / Owner is required');
            }
            // query filter
            let queryStatement = [];
            if (query.collections) {
                queryStatement.push({ address: { _in: query.collections.map(address_1.getAddress) } });
            }
            if (query.minters) {
                queryStatement.push({ minter: { _in: query.minters } });
            }
            if (query.owners) {
                queryStatement.push({ owner: { _in: query.owners } });
            }
            // markets filter
            if (query.activeMarkets) {
                const marketHas = (market) => query.activeMarkets.includes(market);
                if (marketHas(NFTQuery_1.MarketType.AUCTION) || marketHas(NFTQuery_1.MarketType.ANY_MARKET)) {
                    if (additional === null || additional === void 0 ? void 0 : additional.isApproved) {
                        queryStatement.push({
                            currentAuction: { approved: { _eq: additional.isApproved } },
                        });
                    }
                    else {
                        queryStatement.push({ _not: { currentAuction: {} } });
                    }
                }
                if (marketHas(NFTQuery_1.MarketType.FIXED_PRICE) || marketHas(NFTQuery_1.MarketType.ANY_MARKET)) {
                    queryStatement.push({ _not: { v3Ask: {} } });
                }
            }
            // sorting
            let orderByStatement = [
                // set default
                {
                    mintTransferEvent: { blockNumber: zora_indexer_types_1.Order_By.Desc },
                },
            ];
            if (sort) {
                const nestedSorts = sort.map((sortItem) => {
                    const orderBy = sortItem.direction === NFTQuery_1.SortDirection.ASC
                        ? zora_indexer_types_1.Order_By.AscNullsLast
                        : zora_indexer_types_1.Order_By.DescNullsLast;
                    if (sortItem.field === NFTQuery_1.SortField.ACTIVE) {
                        return [{}];
                    }
                    if (sortItem.field === NFTQuery_1.SortField.MINTED) {
                        return [{ mintTransferEvent: { blockNumber: orderBy } }];
                    }
                    if (sortItem.field === NFTQuery_1.SortField.FIXED_PRICE) {
                        return [{ v3Ask: { askPrice: orderBy } }];
                    }
                    if (sortItem.field === NFTQuery_1.SortField.AUCTION_PRICE) {
                        return [{ currentAuction: { reservePrice: orderBy } }];
                    }
                    if (sortItem.field === NFTQuery_1.SortField.ANY_PRICE) {
                        return [
                            { currentAuction: { reservePrice: orderBy } },
                            { v3Ask: { askPrice: orderBy } },
                        ];
                    }
                    if (sortItem.field === NFTQuery_1.SortField.TOKEN_ID) {
                        return [{ tokenId: orderBy }];
                    }
                    return [];
                });
                orderByStatement = nestedSorts.reduce((lastSort, value) => [...lastSort, ...value], []);
            }
            let offset = 0;
            let limit = 100;
            if (pagination === null || pagination === void 0 ? void 0 : pagination.after) {
                offset = parseInt(pagination.after, 10);
            }
            if (pagination === null || pagination === void 0 ? void 0 : pagination.limit) {
                limit = pagination.limit;
            }
            const result = await this.getClient().request(zora_indexer_1.ACTIVE_AUCTIONS_QUERY, {
                andQuery: queryStatement,
                orderBy: orderByStatement,
                offset,
                limit,
            });
            const tokens = result.Token;
            let pageInfo = {};
            pageInfo.last = (offset + limit).toString();
            pageInfo.limit = limit;
            return {
                pageInfo,
                results: tokens.map((nft) => this.transformNFT(nft)),
            };
        };
        /**
         * Un-batched fetch function to fetch a group of NFT data from the zora indexer
         *
         * @param collectionAddresses list of addresses for collection
         * @param userAddress address of user
         * @param type type of ids: creator, id (of media), owner
         * @returns
         */
        this.fetchUserOwnedNFTs = async ({ collectionAddresses, userAddress, offset = 0, limit = 250, }) => {
            let addressQueryPart = {};
            if (collectionAddresses === null || collectionAddresses === void 0 ? void 0 : collectionAddresses.length) {
                addressQueryPart['_in'] = collectionAddresses.map(address_1.getAddress);
            }
            const response = await this.getClient().request(zora_indexer_1.BY_OWNER, {
                addressQueryPart,
                owner: (0, address_1.getAddress)(userAddress),
                offset,
                limit,
            });
            const tokens = response.Token;
            return tokens.map((result) => this.transformNFT(result));
        };
        this.nftGraphDataLoader = new dataloader_1.default(this.fetchNFTs);
        this.timeout = timeout;
        this.endpoint = endpoint;
        this.networkId = networkId;
        this.mediaContractAddress = mediaContractAddress;
    }
    canLoadNFT() {
        return true;
    }
    transformNFT(asset, object) {
        return transformNFTZoraIndexerV1DataSource(asset, object);
    }
    /**
     * Un-batched fetch function to fetch a group of NFT data from the zora indexer
     *
     * @param collectionAddresses list of addresses for collection
     * @param userAddress address of user
     * @param type type of ids: creator, id (of media), owner
     * @returns
     */
    async fetchZoraIndexerUserOwnedNFTs({ collectionAddresses, userAddress, offset = 0, limit = 250, }) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeout);
        const client = new graphql_request_1.GraphQLClient(urls_1.ZORA_INDEXER_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        let addressQueryPart = {};
        if (collectionAddresses === null || collectionAddresses === void 0 ? void 0 : collectionAddresses.length) {
            addressQueryPart['_in'] = collectionAddresses.map(address_1.getAddress);
        }
        const response = await client.request(zora_indexer_1.BY_OWNER, {
            addressQueryPart,
            owner: (0, address_1.getAddress)(userAddress),
            offset,
            limit,
        });
        const tokens = response.Token;
        return tokens.map((token) => this.transformNFT(token));
    }
    getClient() {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeout);
        return new graphql_request_1.GraphQLClient(this.endpoint, {
            fetch: fetchWithTimeout.fetch,
        });
    }
}
exports.ZoraIndexerV1DataSource = ZoraIndexerV1DataSource;
