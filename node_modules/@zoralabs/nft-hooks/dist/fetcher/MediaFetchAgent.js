"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaFetchAgent = void 0;
const timeouts_1 = require("../constants/timeouts");
const CurrencyDataSourceUniswap_1 = require("../backends/currency/CurrencyDataSourceUniswap");
const ZoraUserDataSource_1 = require("../backends/zora-user/ZoraUserDataSource");
const ENSDataSource_1 = require("../backends/ens-reverse/ENSDataSource");
const GenericMediaData_1 = require("../backends/generic-media/GenericMediaData");
/**
 * Internal agent for NFT Hooks to fetch NFT information.
 * Can be used directly for interaction with non-react web frameworks or server frameworks.
 * Uses a cached promise-based API.
 * Fetches from IPFS providers and thegraph.
 */
class MediaFetchAgent {
    constructor(network) {
        /**
         * Gets information of currencies and trading prices from uniswap
         * @param currencies list of currency contract ids on ethereum
         * @returns Promise<CurrencyLookupType>
         */
        this.loadCurrencies = async (currencies) => this.currencyFetcher.loadCurrencies(currencies);
        /**
         * Fetch NFT content or retun URI if content shouild not be fetched
         * @param url NFT Content URL
         * @param contentType string mime type to fetch
         * @returns Promise<MediaContentType> Media content information or URL
         */
        this.fetchContent = (url, contentType) => this.genericMediaFetcher.fetchContent(url, contentType);
        /**
         * Fetch Content MIME type from content URI
         *
         * @param url IPFS Content URI
         * @returns mime type as a string
         * @throws RequestError
         */
        this.fetchContentMimeType = (url) => this.genericMediaFetcher.fetchContentMimeType(url);
        /**
         * Fetch method to query metadata from IPFS. Not cached
         *
         * @function fetchIPFSMetadataCached
         * @public
         * @param url Metadata Source
         * @returns IPFS Metadata Fetch
         * @throws RequestError
         */
        this.fetchIPFSMetadata = (url) => this.genericMediaFetcher.fetchMetadata(url);
        this.timeouts = timeouts_1.DEFAULT_NETWORK_TIMEOUTS_MS;
        this.networkId = network;
        this.currencyFetcher = new CurrencyDataSourceUniswap_1.CurrencyDataSourceUniswap(this.networkId, this.timeouts.Graph);
        this.usernameFetcher = new ZoraUserDataSource_1.ZoraUserDataSource(this.timeouts.Zora);
        this.ensFetcher = new ENSDataSource_1.ENSDataSource(this.networkId, this.timeouts.Rpc);
        this.genericMediaFetcher = new GenericMediaData_1.GenericMediaData(this.timeouts.IPFS);
    }
    /**
     *
     * @param address string address of username to load
     * @returns
     */
    async loadUsername(address) {
        return this.usernameFetcher.loadProfile(address);
    }
    async loadEnsName(address) {
        return (await this.ensFetcher.loadEnsFromAddresses([address]))[address];
    }
    /**
     * Fetches zora username information from blockchain addresses for displaying user
     * information.
     *
     * @param addresses string list of addresses to map to Zora usernames
     * @returns list of UsernameResponseType - all fields are optional except address
     */
    async fetchZoraUsernames(addresses) {
        return this.usernameFetcher.loadProfiles(addresses);
    }
    /**
     * Internal fetch function to retrieve currency information from TheGraph
     *
     * @function fetchCurrenciesGraph
     * @private
     * @param currencyContracts list of Ethereum addresses of currency contract data to retrieve
     * @returns mapped transformed list of ETH currency mapping data
     */
    async fetchCurrenciesGraph(currencyContracts) {
        return this.currencyFetcher.loadCurrencies(currencyContracts);
    }
}
exports.MediaFetchAgent = MediaFetchAgent;
