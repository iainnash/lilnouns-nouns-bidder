"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNFT = void 0;
const tslib_1 = require("tslib");
const react_1 = require("react");
const NFTFetchContext_1 = require("../context/NFTFetchContext");
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
const swr_1 = tslib_1.__importDefault(require("swr"));
/**
 * Fetches on-chain NFT data and pricing for the given nft contract address and id
 *
 * @param contractAddress address of the contract, if null and tokenID is passed in, a NFT is assumed
 * @param tokenId id of NFT to fetch blockchain information for
 * @param options SWR flags and an option to load currency info
 * @returns useNFTType hook results include loading, error, and chainNFT data.
 */
function useNFT(contractAddress, tokenId, options = {}, marketOptions = {}) {
    const dataContext = (0, react_1.useContext)(NFTFetchContext_1.NFTFetchContext);
    const strategy = dataContext.strategy;
    // Fetch media data
    const { data: nftData, error: nftError } = (0, swr_1.default)(contractAddress && tokenId ? ['fetchNFTData', contractAddress, tokenId] : null, (_, address, tokenId) => strategy.fetchNFT(address, tokenId), options);
    // Fetch market data (if needed)
    const { data: nftMarketData, error: nftMarketError } = (0, swr_1.default)(contractAddress &&
        tokenId &&
        strategy.hasSecondaryData({ contract: contractAddress, id: tokenId })
        ? ['fetchSecondaryData', contractAddress, tokenId]
        : null, (_, address, tokenId) => strategy.fetchSecondaryData(address, tokenId, nftData), marketOptions);
    return {
        data: nftData || nftMarketData ? (0, deepmerge_1.default)(nftData || {}, nftMarketData || {}) : undefined,
        currencyLoaded: false,
        error: nftError,
        marketError: nftMarketError,
    };
}
exports.useNFT = useNFT;
