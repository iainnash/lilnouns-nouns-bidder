import { getSdk, Chain, Network, NetworkInput, TokenInput, TokensQueryInput, TokensQueryFilter, CollectionsQueryInput, CollectionSortKeySortInput, TokenSortInput, AggregateAttributesQueryVariables, OwnersByCountQueryVariables, SalesVolumeQueryVariables, EventsQueryInput, EventsQueryFilter, EventSortKeySortInput, MarketSortKeySortInput, MarketsQueryFilter, MarketsQueryInput, MintsQueryFilter, MintsQueryInput, MintSortKeySortInput, FloorPriceQueryVariables, NftCountQueryVariables, SearchQueryVariables, SalesQueryInput, SaleSortKeySortInput, SalesQueryFilter, OwnerCountQueryVariables, PaginationInput } from './queries/queries-sdk';
export { Chain as ZDKChain, Network as ZDKNetwork };
export declare type OverrideNetworksOption = NetworkInput[];
export declare type OverridePaginationOptions = PaginationInput;
declare type SharedQueryParams = {
    networks?: NetworkInput[];
    pagination?: OverridePaginationOptions;
};
export declare type CollectionsQueryArgs = {
    where: CollectionsQueryInput;
    includeFullDetails?: boolean;
    sort: CollectionSortKeySortInput;
} & SharedQueryParams;
export declare type TokensQueryArgs = {
    where: TokensQueryInput;
    filter?: TokensQueryFilter;
    sort?: TokenSortInput;
    includeFullDetails?: boolean;
    includeSalesHistory?: boolean;
} & SharedQueryParams;
export declare type EventsQueryArgs = {
    where: EventsQueryInput;
    sort?: EventSortKeySortInput;
    filter?: EventsQueryFilter;
} & SharedQueryParams;
export declare type MarketQueryArgs = {
    where: MarketsQueryInput;
    sort: MarketSortKeySortInput;
    filter: MarketsQueryFilter;
    includeFullDetails: boolean;
} & SharedQueryParams;
export declare type MintsQueryArgs = {
    where: MintsQueryInput;
    sort?: MintSortKeySortInput;
    filter?: MintsQueryFilter;
    includeFullDetails?: boolean;
    includeMarkets?: boolean;
} & SharedQueryParams;
export declare type SalesQueryArgs = {
    where: SalesQueryInput;
    sort: SaleSortKeySortInput;
    filter: SalesQueryFilter;
    includeFullDetails: boolean;
} & SharedQueryParams;
export declare type CollectionStatsAggregateQuery = {
    collectionAddress: string;
    network: NetworkInput;
};
export declare type TokenQueryArgs = {
    network?: NetworkInput;
    token: TokenInput;
    includeFullDetails?: boolean;
};
export declare type CollectionQueryArgs = {
    address: string;
    network?: NetworkInput;
    includeFullDetails?: boolean;
};
export interface ListOptions<SortInput> {
    networks?: OverrideNetworksOption;
    pagination?: OverridePaginationOptions;
    sort?: SortInput;
    includeFullDetails?: boolean;
}
export declare type SearchQueryArgs = {
    query: string;
    filter?: SearchQueryVariables['filter'];
    pagination?: SearchQueryVariables['pagination'];
};
export interface AggregateOptions {
    networks?: OverrideNetworksOption;
}
export declare type TokenQueryList = TokenInput;
declare type OptionalNetwork<K> = Omit<K, 'networks'> & {
    networks?: OverrideNetworksOption;
};
declare type ZDKOptions = {
    endpoint?: string;
    networks?: OverrideNetworksOption;
    apiKey?: string;
};
export declare class ZDK {
    endpoint: string;
    defaultNetworks: OverrideNetworksOption;
    defaultPageSize: number;
    apiKey?: string;
    sdk: ReturnType<typeof getSdk>;
    constructor({ endpoint, networks, apiKey, }?: ZDKOptions);
    private apiKeyWrapper;
    private getNetworksOption;
    private getPaginationOptions;
    /**
     * A function to query Zora API for a set of NFT collections.
     * @param {TokenQueryArgs} - where, filter, pagination, networks, sort, includeFullDetails
     * @returns {Promise<TokensQuery>}
     */
    tokens: ({ where, filter, pagination, networks, sort, includeFullDetails, includeSalesHistory, }: TokensQueryArgs) => Promise<import("./queries/queries-sdk").TokensQuery>;
    /**
     * A function to query Zora API for a specific token.
     * @param {TokenInput} - token
     * @param {NetworkInput} - token
     * @returns {Promise<TokenQuery>}
     */
    token: ({ token, network, includeFullDetails, }: OptionalNetwork<TokenQueryArgs>) => Promise<import("./queries/queries-sdk").TokenQuery>;
    /**
     * A function to query Zora API for a collection's event set.
     * @param {EventQueryArgs} - networks, filter, pagination, sort, where
     * @returns {Promise<EventsQuery>}
     */
    events: ({ networks, filter, pagination, sort, where, }: EventsQueryArgs) => Promise<import("./queries/queries-sdk").EventsQuery>;
    /**
     * A function to query Zora API for a collection's market data.
     * @param {MarketQueryArgs} - networks, filter, pagination, sort, where, includeFullDetails
     * @returns {Promise<MarketsQuery>}
     */
    markets: ({ networks, filter, pagination, sort, where, includeFullDetails, }: MarketQueryArgs) => Promise<import("./queries/queries-sdk").MarketsQuery>;
    /**
     * A function to query Zora API for a collection's mint data.
     * @param {MintsQueryArgs} - networks, filter, pagination, sort, where, includeFullDetails, includeMarkets
     * @returns {Promise<MintsQuery>}
     */
    mints: ({ networks, filter, pagination, sort, where, includeFullDetails, includeMarkets, }: MintsQueryArgs) => Promise<import("./queries/queries-sdk").MintsQuery>;
    /**
     * A function to query Zora API for a collection's sales data.
     * @param {SalesQueryArgs} - where, networks, filter, pagination, sort, includeFullDetails
     * @returns {Promise<SalesQuery>}
     */
    sales: ({ where, pagination, networks, sort, filter, includeFullDetails, }: SalesQueryArgs) => Promise<import("./queries/queries-sdk").SalesQuery>;
    /**
     * A function to query Zora API for a set of NFT collection's data.
     * @param {CollectionsQueryArgs} - where, networks, pagination, sort, includeFullDetails
     * @returns {Promise<CollectionsQuery>}
     */
    collections: ({ where, pagination, networks, sort, includeFullDetails, }: CollectionsQueryArgs) => Promise<import("./queries/queries-sdk").CollectionsQuery>;
    /**
     * A function to query Zora API for an NFT collection's aggregate statistical data.
     * @param {CollectionStatsAggregateQuery} - networks, collectionAddress
     * @returns {Promise<CollectionStatsAggregateQuery>}
     */
    collectionStatsAggregate: ({ collectionAddress, network, }: CollectionStatsAggregateQuery) => Promise<import("./queries/queries-sdk").CollectionStatsAggregateQuery>;
    /**
     * A function to query Zora API for an NFT collection's data.
     * @param {CollectionQueryArgs} - address, networks, includeFullDetails
     * @returns {Promise<CollectionQuery>}
     */
    collection: ({ address, network, includeFullDetails, }: CollectionQueryArgs) => Promise<{
        __typename?: "Collection" | undefined;
        address: string;
        description: string;
        name?: string | null | undefined;
        symbol?: string | null | undefined;
        totalSupply?: number | null | undefined;
        networkInfo: {
            __typename?: "NetworkInfo" | undefined;
            chain: Chain;
            network: Network;
        };
        attributes?: {
            __typename?: "CollectionAttribute" | undefined;
            traitType?: string | null | undefined;
            valueMetrics: {
                __typename?: "CollectionAttributeValue" | undefined;
                count: number;
                percent: number;
                value: string;
            }[];
        }[] | null | undefined;
    }>;
    /**
     * A function to query Zora API for a set of NFT collection's owners by count.
     * @param {OwnersByCountQueryVariables} - where, networks, pagination
     * @returns {Promise<OwnersByCountQuery>}
     */
    ownersByCount: ({ where, pagination, networks, }: OptionalNetwork<OwnersByCountQueryVariables>) => Promise<import("./queries/queries-sdk").OwnersByCountQuery>;
    /**
     * A function to query Zora API for a set of NFT aggregate attribute data.
     * @param {AggregateAttributesQueryVariable} - where, networks
     * @returns {Promise<AggregateAttributesQuery>}
     */
    aggregateAttributes: ({ where, networks, }: OptionalNetwork<AggregateAttributesQueryVariables>) => Promise<import("./queries/queries-sdk").AggregateAttributesQuery>;
    /**
     * A function to query Zora API for a set of NFT collection's sales volume data.
     * @param {SalesVolumeQueryVariables} - where, networks, TimeFilter
     * @returns {Promise<SalesVolumeQuery>}
     */
    salesVolume: ({ where, networks, filter, }: OptionalNetwork<SalesVolumeQueryVariables>) => Promise<import("./queries/queries-sdk").SalesVolumeQuery>;
    /**
     * A function to query Zora API for a set of NFT owner counts.
     * @param {OwnerCountQueryVariables} - where, networks
     * @returns {Promise<OwnerCountQuery>}
     */
    ownerCount: ({ where, networks, }: OptionalNetwork<OwnerCountQueryVariables>) => Promise<import("./queries/queries-sdk").OwnerCountQuery>;
    /**
     * A function to query Zora API for a set of NFT collection floor prices
     * @param {FloorPriceQueryVariables} - where, networks
     * @returns {Promise<FloorPriceQuery>}
     */
    floorPrice: ({ where, networks, }: OptionalNetwork<FloorPriceQueryVariables>) => Promise<import("./queries/queries-sdk").FloorPriceQuery>;
    /**
     * A function to query Zora API for a set of NFT collection count data.
     * @param {NftCountQueryVariables} - where, networks
     * @returns {Promise<NftCountQuery>}
     */
    nftCount: ({ where, networks, }: OptionalNetwork<NftCountQueryVariables>) => Promise<import("./queries/queries-sdk").NftCountQuery>;
    /**
     * A function to query Zora API to query for an NFT collection with a query string.
     * @param {SearchQueryArgs} - pagination, query, filter
     * @returns {Promise<SearchQuery>}
     */
    search: ({ pagination, query, filter }: SearchQueryArgs) => Promise<import("./queries/queries-sdk").SearchQuery>;
}
